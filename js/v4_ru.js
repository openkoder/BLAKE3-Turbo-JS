/**
 * ============================================================================
 * BLAKE3 - Naive JavaScript Implementation (Working v4)
 * ============================================================================
 * 
 * BLAKE3 - это криптографическая хэш-функция, разработанная в 2020 году.
 * Она объединяет лучшие качества BLAKE2 и Bao (параллельное дерево Меркла).
 * 
 * Основные характеристики:
 * - Размер блока: 64 байта
 * - Размер чанка: 1024 байта (16 блоков)
 * - Размер вывода: 32 байта (по умолчанию), но поддерживает XOF
 * - Количество раундов: 7 (вместо 10 в BLAKE2s)
 * 
 * Структура алгоритма:
 * 1. Входные данные разбиваются на чанки по 1024 байта
 * 2. Каждый чанк обрабатывается как цепочка из 16 блоков по 64 байта
 * 3. Результаты чанков объединяются в дерево Меркла
 * 4. Корень дерева даёт финальный хэш
 * 
 * Вход:  Uint8Array (любой длины)
 * Выход: Uint8Array (32 байта)
 */

/**
 * ============================================================================
 * BLAKE3 v4 — Состояние в памяти на регистрах процессора
 * ============================================================================
 * 
 * Оптимизации в этой версии:
 * - v1: readLittleEndianWordsFull (без проверок границ)
 * - v2: Встроенные перестановки (без копирования массива, предвычисленный порядок доступа)
 * - v3: Инлайнинг round() в compress() + плоский массив перестановок
 * - v4: Состояние в памяти на регистрах процессора
 *       Замена Uint32Array на 16 локальных переменных (SMI)
 *       Полный инлайнинг G-функции с хардкодом индексов
 *       Результат: ускорение ~1.15x (с 88.3 с до 77 мс на 1 МБ данных)
 */

// ============================================================================
// КОНСТАНТЫ
// ============================================================================

/**
 * Вектор инициализации (IV) - первые 32 бита дробной части 
 * квадратных корней первых 8 простых чисел: √2, √3, √5, √7, √11, √13, √17, √19
 * 
 * Эти же константы используются в SHA-256 и BLAKE2s.
 * Они выбраны как "nothing-up-my-sleeve numbers" - числа, которые
 * невозможно подобрать специально для создания backdoor.
 */
const IV = new Uint32Array([
  0x6a09e667,  // √2
  0xbb67ae85,  // √3
  0x3c6ef372,  // √5
  0xa54ff53a,  // √7
  0x510e527f,  // √11
  0x9b05688c,  // √13
  0x1f83d9ab,  // √17
  0x5be0cd19,  // √19
]);

/**
 * Флаги домена - указывают тип обрабатываемого блока.
 * Используются для domain separation (разделения доменов),
 * чтобы одинаковые данные в разных контекстах давали разные хэши.
 */
const CHUNK_START = 1;   // 0b0001 - первый блок в чанке
const CHUNK_END = 2;     // 0b0010 - последний блок в чанке
const PARENT = 4;        // 0b0100 - родительский узел в дереве Меркла
const ROOT = 8;          // 0b1000 - корневой узел (финальный хэш)
// Также существуют: KEYED_HASH = 16, DERIVE_KEY_CONTEXT = 32, DERIVE_KEY_MATERIAL = 64

/**
 * Размер блока в байтах.
 * BLAKE3 обрабатывает данные блоками по 64 байта = 16 слов по 4 байта.
 */
const BLOCK_LEN = 64;

/**
 * Предвычисленные индексы перестановок в плосском массиве для всех 7 раундов.
 * 
 * Вместо физического перемещения данных в массиве сообщения после каждого раунда
 * (что требует создания временной копии), мы предвычисляем ПОРЯДОК ДОСТУПА
 * к исходным данным для каждого раунда.
 * 
 * Принцип работы:
 * - Оригинальный подход: permute(m) копирует массив и перетасовывает данные после каждого раунда
 * - Оптимизированный подход v2: обращаемся к m[ROUND_PERMUTATIONS[round][i]] с предвычисленными индексами
 * - Оптимизированный подход v3: обращаемся к PERMUTATIONS[r * 16 + i], где раунд r, индекс i (плоский массив + бегущий указатель)
 * 
 * Преимущества плоского Uint8Array перед двумерным Array[][]:
 * - Линейное хранение в памяти → лучшая локальность кэша (cache locality)
 * - Простая арифметика адресации: p++ вместо [round][index]
 * - Uint8Array хранится в непрерывной области → идеально для CPU prefetcher
 * - Индексы 0-15 умещаются в байт → компактность (112 байт vs ~900+ для Array)
 * - JIT-компилятор видит последовательный паттерн доступа
 * 
 * Экономия памяти на каждый вызов compress():
 * - Без оптимизации: 7 × 64 байта = 448 байт аллоцируется (копии массива m)
 * - С оптимизацией: 0 байт аллоцируется (только чтение из статического массива)
 * 
 * Размер: 7 раундов × 16 индексов = 112 элементов
 * Адресация: раунд r, индекс i → PERMUTATIONS[r * 16 + i]
 * (но мы используем бегущий указатель p++ для ещё большей эффективности)
 * 
 /**
 * Плоский массив перестановок для 7 раундов.
 * 
 * Линейное хранение: раунд r, индекс i → PERMUTATIONS[r * 16 + i]
 * Использование Uint8Array обеспечивает компактность и cache-friendliness.
 */
const PERMUTATIONS = new Uint8Array([
  // Раунд 1: тождественная
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  // Раунд 2
  2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8,
  // Раунд 3
  3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1,
  // Раунд 4
  10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6,
  // Раунд 5
  12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4,
  // Раунд 6
  9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7,
  // Раунд 7
  11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13,
]);


// ============================================================================
// ФУНКЦИЯ СЖАТИЯ
// ============================================================================

/**
 * Функция сжатия — основная криптографическая операция BLAKE3.
 * 
 * Функция сжатия BLAKE3 с хранением состояния в регистрах.
 * 
 * Вместо использования Uint32Array для состояния (что требует обращения к памяти),
 * мы используем 16 локальных переменных s_0...s_15, которые JIT-компилятор
 * может разместить непосредственно в регистрах процессора.
 * 
 * Это устраняет:
 * - 448 записей в массив за один вызов compress()
 * - 1008 чтений из массива за один вызов compress()
 * - Накладные расходы на проверку границ
 * - Косвенную адресацию памяти
 * 
 * G-функция полностью встроена с захардкоженными индексами.
 * Код сгенерирован с помощью метапрограммирования (см. генератор в комментариях).
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * СТРУКТУРА НАЧАЛЬНОГО СОСТОЯНИЯ (16 слов = 512 бит)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   ┌─────────────────────────────────────────────────────────────────────┐
 *   │  s_0    s_1    s_2    s_3   ← цепное значение [0..3]                │
 *   │  s_4    s_5    s_6    s_7   ← цепное значение [4..7]                │
 *   │  s_8    s_9    s_10   s_11  ← константы IV (корни простых чисел)    │
 *   │  s_12   s_13   s_14   s_15  ← счётчик_мл, счётчик_ст, длина, флаги  │
 *   └─────────────────────────────────────────────────────────────────────┘
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * СТРУКТУРА РАУНДА (всего 7 раундов)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Каждый раунд применяет G-функцию ко всем 16 словам состояния в две фазы:
 * 
 * Фаза 1 — СТОЛБЦЫ:           Фаза 2 — ДИАГОНАЛИ:
 * 
 *   ┌────┬────┬────┬────┐       ┌────┬────┬────┬────┐
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │ ↘  │  ↘ │    │↘   │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │    │ ↘  │  ↘ │    │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │    │    │ ↘  │  ↘ │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │  ↘ │    │    │ ↘  │
 *   └────┴────┴────┴────┘       └────┴────┴────┴────┘
 * 
 *   G(0,4,8,12)   G(1,5,9,13)     G(0,5,10,15)  G(1,6,11,12)
 *   G(2,6,10,14)  G(3,7,11,15)    G(2,7,8,13)   G(3,4,9,14)
 * 
 * Всего операций: 7 раундов × 8 вызовов G × 12 операций = 672 операции
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * G-ФУНКЦИЯ (ARX — сложение-вращение-XOR)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   a ← a + b + mx        a ← a + b + my
 *   d ← (d ⊕ a) >>> 16    d ← (d ⊕ a) >>> 8
 *   c ← c + d             c ← c + d
 *   b ← (b ⊕ c) >>> 12    b ← (b ⊕ c) >>> 7
 * 
 * Константы вращения (16, 12, 8, 7) оптимизированы для 32-битной диффузии.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * ФИНАЛИЗАЦИЯ
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   выход[0..7]  = младшая_часть ⊕ старшая_часть  (прямая связь для цепочки)
 *   выход[8..15] = старшая_часть ⊕ cv             (для расширенного вывода XOF)
 * 
 * @param {Uint32Array} cv        - Цепное значение (8 × 32-битных слов)
 * @param {Uint32Array} m         - Блок сообщения (16 × 32-битных слов)
 * @param {number}      counter   - 64-битный счётчик блоков (как число JS)
 * @param {number}      blockLen  - Длина блока в байтах (0-64)
 * @param {number}      flags     - Флаги разделения доменов
 * @returns {Uint32Array}         - 512-битный выход (16 × 32-битных слов)
 */
function compress(cv, m, counter, blockLen, flags) {
  // ═══════════════════════════════════════════════════════════════════════
  // Инициализация состояния — 16 локальных переменных вместо Uint32Array
  // ═══════════════════════════════════════════════════════════════════════
  let s_0 = cv[0] | 0;
  let s_1 = cv[1] | 0;
  let s_2 = cv[2] | 0;
  let s_3 = cv[3] | 0;
  let s_4 = cv[4] | 0;
  let s_5 = cv[5] | 0;
  let s_6 = cv[6] | 0;
  let s_7 = cv[7] | 0;
  let s_8 = 0x6A09E667;   // IV[0] — sqrt(2)
  let s_9 = 0xBB67AE85;   // IV[1] — sqrt(3)
  let s_10 = 0x3C6EF372;  // IV[2] — sqrt(5)
  let s_11 = 0xA54FF53A;  // IV[3] — sqrt(7)
  let s_12 = counter | 0;                   // Младшие 32 бита счётчика
  let s_13 = (counter / 0x100000000) | 0;   // Старшие 32 бита счётчика
  let s_14 = blockLen | 0;
  let s_15 = flags | 0;

  // ═══════════════════════════════════════════════════════════════════════
  // 🚀 ИНЛАЙНИНГ ФУНКЦИИ round(): 7 раундов в одном цикле
  // ═══════════════════════════════════════════════════════════════════════
  // 
  // Раунд применяет G-функцию ко всем 16 словам состояния.
  // Состояние представлено как матрица 4×4:
  // 
  //   ┌──────┬──────┬──────┬──────┐
  //   │  0   │  1   │  2   │  3   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  4   │  5   │  6   │  7   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  8   │  9   │ 10   │ 11   │
  //   ├──────┼──────┼──────┼──────┤
  //   │ 12   │ 13   │ 14   │ 15   │
  //   └──────┴──────┴──────┴──────┘
  // 
  // Каждый раунд состоит из двух фаз:
  // 
  // 1. СТОЛБЦЫ — G применяется к каждому столбцу:
  //    G(0,4,8,12)  G(1,5,9,13)  G(2,6,10,14)  G(3,7,11,15)
  // 
  // 2. ДИАГОНАЛИ — G применяется к диагоналям:
  //    G(0,5,10,15) G(1,6,11,12) G(2,7,8,13)   G(3,4,9,14)
  // 
  // ───────────────────────────────────────────────────────────────────────
  // ОПТИМИЗАЦИЯ v3: Инлайнинг + плоский массив перестановок
  // ───────────────────────────────────────────────────────────────────────
  // 
  // Вместо 7 вызовов функции round():
  //   round(state, blockWords, ROUND_PERMUTATIONS[0]);
  //   round(state, blockWords, ROUND_PERMUTATIONS[1]);
  //   ... (7 вызовов)
  // 
  // Мы используем один цикл с бегущим указателем p в плоском
  // массиве PERMUTATIONS. Это позволяет избежать:
  // - Накладных расходов на 7 вызовов функции round()
  // - 2D-индексации ROUND_PERMUTATIONS[round][index]
  // - Копирования блока сообщения (без `new Uint32Array(m)`)
  // - Вызова permute() после каждого раунда (без перемещения данных)
  // 
  // Экономия на один вызов compress():
  // - 7 выделений стекового фрейма
  // - 7 × 16 = 112 операций индексации в 2D-массиве
  // - Улучшенная локальность кэша благодаря линейному доступу к PERMUTATIONS
  // 
  // BLAKE2 имеет 10 раундов, BLAKE3 оптимизирован до 7 для скорости.
  // ═══════════════════════════════════════════════════════════════════════
  
  // Используем один цикл с бегущим указателем:
  let p = 0;  // Указатель в плоском массиве PERMUTATIONS
  
  for (let round = 0; round < 7; ++round) {
    // ─────────────────────────────────────────────────────────────
    // Фаза 1: Перемешивание по столбцам
    // G(0,4,8,12), G(1,5,9,13), G(2,6,10,14), G(3,7,11,15)
    // ─────────────────────────────────────────────────────────────
    // G применяется вертикально к каждому из 4 столбцов.
    //
    // Слова сообщения доступны через m[PERMUTATIONS[p++]], где p
    // автоматически продвигается по плоскому массиву перестановок.

    // G(0, 4, 8, 12)
    s_0 = (((s_0 + s_4) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_12 ^= s_0;
    s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_8 = (s_8 + s_12) | 0;
    s_4 ^= s_8;
    s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_0 = (((s_0 + s_4) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_12 ^= s_0;
    s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_8 = (s_8 + s_12) | 0;
    s_4 ^= s_8;
    s_4 = (s_4 >>> 7) | (s_4 << 25);

    // G(1, 5, 9, 13)
    s_1 = (((s_1 + s_5) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_13 ^= s_1;
    s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_9 = (s_9 + s_13) | 0;
    s_5 ^= s_9;
    s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_1 = (((s_1 + s_5) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_13 ^= s_1;
    s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_9 = (s_9 + s_13) | 0;
    s_5 ^= s_9;
    s_5 = (s_5 >>> 7) | (s_5 << 25);

    // G(2, 6, 10, 14)
    s_2 = (((s_2 + s_6) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_14 ^= s_2;
    s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_10 = (s_10 + s_14) | 0;
    s_6 ^= s_10;
    s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_2 = (((s_2 + s_6) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_14 ^= s_2;
    s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_10 = (s_10 + s_14) | 0;
    s_6 ^= s_10;
    s_6 = (s_6 >>> 7) | (s_6 << 25);

    // G(3, 7, 11, 15)
    s_3 = (((s_3 + s_7) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_15 ^= s_3;
    s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_11 = (s_11 + s_15) | 0;
    s_7 ^= s_11;
    s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_3 = (((s_3 + s_7) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_15 ^= s_3;
    s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_11 = (s_11 + s_15) | 0;
    s_7 ^= s_11;
    s_7 = (s_7 >>> 7) | (s_7 << 25);
    
    // ─────────────────────────────────────────────────────────────
    // Фаза 2: Перемешивание по диагоналям
    // G(0,5,10,15), G(1,6,11,12), G(2,7,8,13), G(3,4,9,14)
    // ─────────────────────────────────────────────────────────────
    // G применяется вдоль диагоналей с переносом.
    //
    
    // G(0, 5, 10, 15)
    s_0 = (((s_0 + s_5) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_15 ^= s_0;
    s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_10 = (s_10 + s_15) | 0;
    s_5 ^= s_10;
    s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_0 = (((s_0 + s_5) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_15 ^= s_0;
    s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_10 = (s_10 + s_15) | 0;
    s_5 ^= s_10;
    s_5 = (s_5 >>> 7) | (s_5 << 25);

    // G(1, 6, 11, 12)
    s_1 = (((s_1 + s_6) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_12 ^= s_1;
    s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_11 = (s_11 + s_12) | 0;
    s_6 ^= s_11;
    s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_1 = (((s_1 + s_6) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_12 ^= s_1;
    s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_11 = (s_11 + s_12) | 0;
    s_6 ^= s_11;
    s_6 = (s_6 >>> 7) | (s_6 << 25);

    // G(2, 7, 8, 13)
    s_2 = (((s_2 + s_7) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_13 ^= s_2;
    s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_8 = (s_8 + s_13) | 0;
    s_7 ^= s_8;
    s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_2 = (((s_2 + s_7) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_13 ^= s_2;
    s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_8 = (s_8 + s_13) | 0;
    s_7 ^= s_8;
    s_7 = (s_7 >>> 7) | (s_7 << 25);

    // G(3, 4, 9, 14)
    s_3 = (((s_3 + s_4) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_14 ^= s_3;
    s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_9 = (s_9 + s_14) | 0;
    s_4 ^= s_9;
    s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_3 = (((s_3 + s_4) | 0) + m[PERMUTATIONS[p++]]) | 0;
    s_14 ^= s_3;
    s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_9 = (s_9 + s_14) | 0;
    s_4 ^= s_9;
    s_4 = (s_4 >>> 7) | (s_4 << 25);
  }

  // ═══════════════════════════════════════════════════════════════════════
  // Финализация: XOR верхней и нижней половин состояния
  // Это "сжимает" 512 бит до 256 бит и добавляет прямую связь
  // ═══════════════════════════════════════════════════════════════════════
  return new Uint32Array([
    s_0 ^ s_8,
    s_1 ^ s_9,
    s_2 ^ s_10,
    s_3 ^ s_11,
    s_4 ^ s_12,
    s_5 ^ s_13,
    s_6 ^ s_14,
    s_7 ^ s_15,
    s_8 ^ cv[0],
    s_9 ^ cv[1],
    s_10 ^ cv[2],
    s_11 ^ cv[3],
    s_12 ^ cv[4],
    s_13 ^ cv[5],
    s_14 ^ cv[6],
    s_15 ^ cv[7],
  ]);
}

/**
 * Извлекает первые 8 слов (256 бит) из результата сжатия.
 * 
 * Это "сцепляющее значение" (chaining value), которое передаётся
 * в следующий блок или используется как узел дерева Меркла.
 * 
 * @param {Uint32Array} compressionOutput - результат compress (16 слов)
 * @returns {Uint32Array} - первые 8 слов (новый массив)
 */
function first8Words(compressionOutput) {
  return new Uint32Array(compressionOutput).slice(0, 8);
}

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * Читает байты как little-endian 32-битные слова.
 * 
 * Little-endian означает, что младший байт идёт первым.
 * Пример: байты [0x78, 0x56, 0x34, 0x12] → слово 0x12345678
 * 
 * Функция также обрабатывает неполные блоки (паддинг нулями).
 * 
 * @param {Uint8Array} array - входные байты
 * @param {number} offset - начальная позиция
 * @param {Uint32Array} words - массив для записи слов (16 элементов)
 */
// ═══════════════════════════════════════════════════════════════════════════
// ✅ ОПТИМИЗАЦИЯ: Две версии функции чтения
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Быстрое чтение полного блока (64 байта).
 * Без проверок границ - для 99% вызовов.
 */
function readLittleEndianWordsFull(array, offset, words) {
  for (let i = 0; i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
}

/**
 * Чтение неполного блока с padding.
 * Только для последнего блока данных.
 */
function readLittleEndianWordsPartial(array, offset, words) {
  let i = 0;
  for (; offset + 3 < array.length && i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
  for (let j = i; j < 16; ++j) words[j] = 0;
  for (let s = 0; offset < array.length; s += 8, ++offset) {
    words[i] |= array[offset] << s;
  }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

/**
 * Вычисляет BLAKE3 хэш входных данных.
 * 
 * Алгоритм работает в три этапа:
 * 
 * 1. ОБРАБОТКА ПОЛНЫХ ЧАНКОВ (по 1024 байта):
 *    - Каждый чанк состоит из 16 блоков по 64 байта
 *    - Блоки цепочкой сжимаются в одно 256-битное значение
 *    - Результаты чанков складываются в стек для дерева Меркла
 * 
 * 2. ОБРАБОТКА ПОСЛЕДНЕГО (НЕПОЛНОГО) ЧАНКА:
 *    - Может содержать от 0 до 1023 байт
 *    - Паддится нулями до границы блока
 * 
 * 3. ПОСТРОЕНИЕ ДЕРЕВА МЕРКЛА:
 *    - Пары узлов объединяются в родительские узлы
 *    - Повторяется до получения единственного корня
 *    - Корень хэшируется с флагом ROOT
 * 
 * Визуализация дерева для 4 чанков:
 * 
 *              ROOT
 *             /    \
 *        PARENT    PARENT
 *        /   \     /    \
 *     CV0   CV1  CV2   CV3
 *      |     |    |     |
 *   Chunk0 Chunk1 Chunk2 Chunk3
 * 
 * @param {Uint8Array} input - входные данные
 * @returns {Uint8Array} - хэш (32 байта)
 */
function blake3(input) {
  // Проверка типа входных данных
  if (!(input instanceof Uint8Array)) {
    throw new Error('Input must be Uint8Array');
  }

  // Инициализация
  const flags = 0;                    // Базовые флаги (можно добавить KEYED_HASH и др.)
  const keyWords = IV;                // Ключ (IV для обычного хэширования)
  const blockWords = new Uint32Array(16);  // Буфер для блока
  const cvStack = [];                 // Стек для дерева Меркла

  let chunkCounter = 0;               // Счётчик обработанных чанков
  let offset = 0;                     // Текущая позиция во входных данных

  const length = input.length;
  
  // Вычисляем, сколько полных чанков обработать
  // take = наибольшее число, кратное 1024, которое < length
  let take = length - (length % 1024);
  if (take === length && length > 0) { 
    // Если длина кратна 1024, последний чанк все равно обрабатывается отдельно (как partial),
    // или как полный, но с флагом CHUNK_END. 
    // В оригинальной логике take должен быть меньше length, если length > 0.
    take -= 1024;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 1: Обработка полных чанков (по 1024 байта = 16 блоков)
  // ═══════════════════════════════════════════════════════════════════════
  
  for (; offset < take; ) {
    let cv = keyWords;  // Сцепляющее значение (начинаем с IV)

    // Обрабатываем 16 блоков чанка
    for (let i = 0; i < 16; ++i, offset += 64) {
      readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

      // Определяем флаги для блока:
      // - Первый блок: CHUNK_START
      // - Последний блок (15-й): CHUNK_END
      // - Остальные: без флагов
      cv = first8Words(
        compress(
          cv,
          blockWords,
          chunkCounter,
          BLOCK_LEN,
          flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
        )
      );
    }

    chunkCounter += 1;
    cvStack.push(cv);  // Добавляем результат чанка в стек

    // Объединяем узлы дерева Меркла, пока можем
    // (пока количество чанков кратно 2)
    let totalChunks = chunkCounter;
    while ((totalChunks & 1) === 0) {
      // Извлекаем два дочерних узла
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      
      // Формируем блок для родительского узла:
      // левый потомок (8 слов) + правый потомок (8 слов) = 16 слов
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      
      // Сжимаем с флагом PARENT
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
      
      totalChunks >>= 1;
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 2: Обработка последнего (возможно неполного) чанка
  // ═══════════════════════════════════════════════════════════════════════

  const remainingBytes = length - take;
  const fullBlocks = remainingBytes > 0 ? ((remainingBytes - 1) / 64) | 0 : 0;

  let cv = keyWords;

  // Обрабатываем полные блоки последнего чанка
  for (let i = 0; i < fullBlocks; ++i, offset += 64) {
    readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        BLOCK_LEN,
        flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
      )
    );
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 3: Финализация - обработка последнего блока и построение корня
  // ═══════════════════════════════════════════════════════════════════════

  let finalChainingValue;
  let finalBlockLen;
  let finalFlags;

  // Читаем последний блок (может быть неполным)
  readLittleEndianWordsPartial(input, offset, blockWords);  // ✅ С проверками границ

  if (cvStack.length === 0) {
    // Особый случай: все данные помещаются в один чанк
    // Финальный блок - это и корень дерева
    finalChainingValue = cv;
    finalBlockLen = length - offset;
    finalFlags = flags | ROOT | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0);
  } else {
    // Общий случай: нужно построить дерево Меркла
    finalChainingValue = keyWords;
    finalBlockLen = BLOCK_LEN;
    finalFlags = flags | PARENT | ROOT;

    // Завершаем последний чанк
    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        length - offset,
        flags | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0)
      )
    );

    cvStack.push(cv);

    // Объединяем оставшиеся узлы в дерево
    while (cvStack.length > 2) {
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
    }

    // Подготавливаем финальный блок из двух последних узлов
    const rightChildCv = cvStack.pop();
    const leftChildCv = cvStack.pop();
    blockWords.set(leftChildCv, 0);
    blockWords.set(rightChildCv, 8);
  }

  // Финальное сжатие с флагом ROOT
  const out = compress(
    finalChainingValue,
    blockWords,
    0,
    finalBlockLen,
    finalFlags
  );

  // Возвращаем первые 32 байта (256 бит) как хэш
  return new Uint8Array(out.buffer, 0, 32);
}
const hash = blake3;

// ============================================================================
// ЭКСПОРТ
// ============================================================================

export { blake3 };

/*
┌─────────────────────────────────────────────────────────────────┐
│                         ВХОДНЫЕ ДАННЫЕ                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Разбиение на ЧАНКИ (1024 байта = 16 блоков по 64 байта)        │
└─────────────────────────────────────────────────────────────────┘
                              │
            ┌─────────────────┼─────────────────┐
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │ Chunk 0 │       │ Chunk 1 │       │ Chunk N │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │   CV0   │       │   CV1   │       │   CVN   │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            └────────┬────────┴────────┬────────┘
                     ▼                 ▼
                ┌─────────┐       ┌─────────┐
                │ PARENT  │       │ PARENT  │
                └────┬────┘       └────┬────┘
                     └────────┬────────┘
                              ▼
                         ┌─────────┐
                         │  ROOT   │
                         └────┬────┘
                              │
                              ▼
                   ┌───────────────────┐
                   │   HASH (32 bytes) │
                   └───────────────────┘
*/
