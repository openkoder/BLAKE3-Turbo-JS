/**
 * ============================================================================
 * BLAKE3 - Naive JavaScript Implementation (Working v8)
 * ============================================================================
 * 
 * BLAKE3 - это криптографическая хэш-функция, разработанная в 2020 году.
 * Она объединяет лучшие качества BLAKE2 и Bao (параллельное дерево Меркла).
 * 
 * Основные характеристики:
 * - Размер блока: 64 байта
 * - Размер чанка: 1024 байта (16 блоков)
 * - Размер вывода: 32 байта (по умолчанию), но поддерживает XOF
 * - Количество раундов: 7 (вместо 10 в BLAKE2s)
 * 
 * Структура алгоритма:
 * 1. Входные данные разбиваются на чанки по 1024 байта
 * 2. Каждый чанк обрабатывается как цепочка из 16 блоков по 64 байта
 * 3. Результаты чанков объединяются в дерево Меркла
 * 4. Корень дерева даёт финальный хэш
 * 
 * Вход:  Uint8Array (любой длины)
 * Выход: Uint8Array (32 байта)
 */

/**
 * ============================================================================
 * BLAKE3 v8 — Little-Endian без копирования (Zero-Copy)
 * ============================================================================
 * 
 * Оптимизации в этой версии:
 * - v1: readLittleEndianWordsFull (без проверок границ)
 * - v2: Встроенные перестановки (без копирования массива, предвычисленный порядок доступа)
 * - v3: Инлайнинг round() в compress() + плоский массив перестановок
 * - v4: Состояние в памяти на регистрах процессора
 *       Замена Uint32Array на 16 локальных переменных (SMI)
 *       Полный инлайнинг G-функции с хардкодом индексов
 * - v5: Zero-copy — in-place запись в compress() в out[outOffset...], cvStack как Uint32Array
 * - v6: Блок сообщения в локальных переменных message_0...message_15
 *       Удаление таблицы PERMUTATIONS, физическая перестановка
 *       Результат: ускорение ~1.26x (с 9.3 мс до 7.4 мс на 1 МБ данных)
 * - v7: Переиспользование глобальных буферов (workBuffer, cvStack)
 *       Функция getCvStack() с grow-only кэшированием
 *       Устранение аллокаций при повторных вызовах blake3()
 * - v8: Little-Endian без копирования (Zero-Copy)
 *       Детекция порядка байтов: IsBigEndian = !new Uint8Array(new Uint32Array([1]).buffer)[0]
 *       Создание Uint32Array view на входной буфер (без копирования данных)
 *       compress() читает напрямую из inputWords вместо workBuffer
 *       Полное устранение readLittleEndianWordsFull для полных блоков
 *       Проверка выравнивания буфера (byteOffset % 4 === 0)
 *       Результат: ускорение ~1.33x (с 7.7 мс до 5.8 мс на 1 МБ данных)
 */

// ============================================================================
// КОНСТАНТЫ
// ============================================================================

/**
 * Вектор инициализации (IV) - первые 32 бита дробной части 
 * квадратных корней первых 8 простых чисел: √2, √3, √5, √7, √11, √13, √17, √19
 * 
 * Эти же константы используются в SHA-256 и BLAKE2s.
 * Они выбраны как "nothing-up-my-sleeve numbers" - числа, которые
 * невозможно подобрать специально для создания backdoor.
 */
const IV = new Uint32Array([
  0x6a09e667,  // √2
  0xbb67ae85,  // √3
  0x3c6ef372,  // √5
  0xa54ff53a,  // √7
  0x510e527f,  // √11
  0x9b05688c,  // √13
  0x1f83d9ab,  // √17
  0x5be0cd19,  // √19
]);

/**
 * Флаги домена - указывают тип обрабатываемого блока.
 * Используются для domain separation (разделения доменов),
 * чтобы одинаковые данные в разных контекстах давали разные хэши.
 */
const CHUNK_START = 1;   // 0b0001 - первый блок в чанке
const CHUNK_END = 2;     // 0b0010 - последний блок в чанке
const PARENT = 4;        // 0b0100 - родительский узел в дереве Меркла
const ROOT = 8;          // 0b1000 - корневой узел (финальный хэш)
// Также существуют: KEYED_HASH = 16, DERIVE_KEY_CONTEXT = 32, DERIVE_KEY_MATERIAL = 64

/**
 * Размер блока в байтах.
 * BLAKE3 обрабатывает данные блоками по 64 байта = 16 слов по 4 байта.
 */
const BLOCK_LEN = 64;
const CHUNK_LEN = 1024;

// Детекция порядка байтов (выполняется один раз при загрузке модуля)
const IsBigEndian = !new Uint8Array(new Uint32Array([1]).buffer)[0];

// ═══════════════════════════════════════════════════════════════════════
// ГЛОБАЛЬНЫЕ ПЕРЕИСПОЛЬЗУЕМЫЕ предаллоцированные БУФЕРЫ
// глобальные буферы (создаются один раз при загрузке модуля)
// никаких аллокаций в функции blake3() и горячем цикле
// ═══════════════════════════════════════════════════════════════════════

// Буфер для текущего CV (8 слов) и блока сообщения (16 слов)
// Объединяем в один массив для лучшей локальности
const globalWorkBuffer = new Uint32Array(8 + 16);  // cv[0..7] + block[0..15]

// Кэшированный стек CV — растёт при необходимости, но никогда не уменьшается
let globalCvStack = null;


/**
 * Получить стек CV нужного размера.
 * Переиспользует существующий, если он достаточно большой.
 * 
 * @param {number} inputLength - длинна входа для подсчета глубины дерева
 * @returns {Uint32Array} - Стек достаточного размера
 */
function getCvStack(inputLength) {
  // Максимальная глубина дерева: log2(max_chunks)
  const maxDepth = Math.log2(1 + Math.ceil(inputLength / 1024)) + 1;
  // Минимум 54 уровней — покрывает файлы длинной до 2^54 чанков
  const depth = Math.max(maxDepth, 54);
  const length = depth * 8;
  
  if (globalCvStack === null || globalCvStack.length < length) {
    // Создаём новый только если старый слишком мал
    globalCvStack = new Uint32Array(length);
  }
  
  return globalCvStack;
}


// ============================================================================
// ФУНКЦИЯ СЖАТИЯ
// ============================================================================

/**
 * Функция сжатия - основная криптографическая операция BLAKE3.
 * 
 * Функция сжатия BLAKE3 с in-place записью результата и 
 * с хранением состояния в регистрах.
 * 
 * Вместо использования Uint32Array для состояния (что требует обращения к памяти),
 * мы используем 16 локальных переменных s_0...s_15, которые JIT-компилятор
 * может разместить непосредственно в регистрах процессора.
 * 
 * Это устраняет:
 * - 448 записей в массив за один вызов compress()
 * - 1008 чтений из массива за один вызов compress()
 * - Накладные расходы на проверку границ
 * - Косвенную адресацию памяти
 * 
 * G-функция полностью встроена с захардкоженными индексами.
 * Код сгенерирован с помощью метапрограммирования (см. генератор в комментариях).
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * СТРУКТУРА НАЧАЛЬНОГО СОСТОЯНИЯ (16 слов = 512 бит)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   ┌─────────────────────────────────────────────────────────────────────┐
 *   │  s_0    s_1    s_2    s_3   ← цепное значение [0..3]                │
 *   │  s_4    s_5    s_6    s_7   ← цепное значение [4..7]                │
 *   │  s_8    s_9    s_10   s_11  ← константы IV (корни простых чисел)    │
 *   │  s_12   s_13   s_14   s_15  ← счётчик_мл, счётчик_ст, длина, флаги  │
 *   └─────────────────────────────────────────────────────────────────────┘
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * СТРУКТУРА РАУНДА (всего 7 раундов)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Каждый раунд применяет G-функцию ко всем 16 словам состояния в две фазы:
 * 
 * Фаза 1 - СТОЛБЦЫ:           Фаза 2 - ДИАГОНАЛИ:
 * 
 *   ┌────┬────┬────┬────┐       ┌────┬────┬────┬────┐
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │ ↘  │  ↘ │    │↘   │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │    │ ↘  │  ↘ │    │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │    │    │ ↘  │  ↘ │
 *   ├────┼────┼────┼────┤       ├────┼────┼────┼────┤
 *   │ ↓  │ ↓  │ ↓  │ ↓  │       │  ↘ │    │    │ ↘  │
 *   └────┴────┴────┴────┘       └────┴────┴────┴────┘
 * 
 *   G(0,4,8,12)   G(1,5,9,13)     G(0,5,10,15)  G(1,6,11,12)
 *   G(2,6,10,14)  G(3,7,11,15)    G(2,7,8,13)   G(3,4,9,14)
 * 
 * Всего операций: 7 раундов × 8 вызовов G × 12 операций = 672 операции
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * G-ФУНКЦИЯ (ARX - сложение-вращение-XOR)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   a ← a + b + mx        a ← a + b + my
 *   d ← (d ⊕ a) >>> 16    d ← (d ⊕ a) >>> 8
 *   c ← c + d             c ← c + d
 *   b ← (b ⊕ c) >>> 12    b ← (b ⊕ c) >>> 7
 * 
 * Константы вращения (16, 12, 8, 7) оптимизированы для 32-битной диффузии.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * ФИНАЛИЗАЦИЯ
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 *   выход[0..7]  = младшая_часть ⊕ старшая_часть  (прямая связь для цепочки)
 *   выход[8..15] = старшая_часть ⊕ cv             (для расширенного вывода XOF)
 * 
 * @param {Uint32Array} cv        - Цепное значение chaining value (8 × 32-битных слов)
 * @param {number}      cvOffset  - Смещение CV в массиве
 * @param {Uint32Array} m         - Блок сообщения (16 × 32-битных слов)
 * @param {number}      mOffset   - Смещение блока в массиве
 * @param {Uint32Array} out       - Массив для записи результата
 * @param {number}      outOffset - Смещение для записи результата
 * @param {boolean}     truncate  - true = записать только 8 слов (CV)
 *                                  false = записать все 16 слов (XOF)
 * @param {number}      counter   - 64-битный счётчик блоков (как число JS)
 * @param {number}      blockLen  - Длина блока в байтах (0-64)
 * @param {number}      flags     - Флаги разделения доменов
 * @returns {Uint32Array}         - 512-битный выход (16 × 32-битных слов)
 */
function compress(
  cv, cvOffset,
  m, mOffset,
  out, outOffset,
  truncate,
  counter, blockLen, flags
) {
  // ═══════════════════════════════════════════════════════════════════════
  // Инициализация состояния - 16 локальных переменных вместо Uint32Array
  // ═══════════════════════════════════════════════════════════════════════
  let s_0 = cv[cvOffset + 0] | 0;
  let s_1 = cv[cvOffset + 1] | 0;
  let s_2 = cv[cvOffset + 2] | 0;
  let s_3 = cv[cvOffset + 3] | 0;
  let s_4 = cv[cvOffset + 4] | 0;
  let s_5 = cv[cvOffset + 5] | 0;
  let s_6 = cv[cvOffset + 6] | 0;
  let s_7 = cv[cvOffset + 7] | 0;
  let s_8 = 0x6A09E667;   // IV[0] - sqrt(2)
  let s_9 = 0xBB67AE85;   // IV[1] - sqrt(3)
  let s_10 = 0x3C6EF372;  // IV[2] - sqrt(5)
  let s_11 = 0xA54FF53A;  // IV[3] - sqrt(7)
  let s_12 = counter | 0;                   // Младшие 32 бита счётчика
  let s_13 = (counter / 0x100000000) | 0;   // Старшие 32 бита счётчика
  let s_14 = blockLen | 0;
  let s_15 = flags | 0;
  
  // ═══════════════════════════════════════════════════════════════════════
  // Инициализация сообщения message_ - 16 локальных переменных вместо Uint32Array
  // НОВОЕ: Блок сообщения тоже в локальных переменных!
  // ═══════════════════════════════════════════════════════════════════════
  let message_0 = m[mOffset + 0] | 0;
  let message_1 = m[mOffset + 1] | 0;
  let message_2 = m[mOffset + 2] | 0;
  let message_3 = m[mOffset + 3] | 0;
  let message_4 = m[mOffset + 4] | 0;
  let message_5 = m[mOffset + 5] | 0;
  let message_6 = m[mOffset + 6] | 0;
  let message_7 = m[mOffset + 7] | 0;
  let message_8 = m[mOffset + 8] | 0;
  let message_9 = m[mOffset + 9] | 0;
  let message_10 = m[mOffset + 10] | 0;
  let message_11 = m[mOffset + 11] | 0;
  let message_12 = m[mOffset + 12] | 0;
  let message_13 = m[mOffset + 13] | 0;
  let message_14 = m[mOffset + 14] | 0;
  let message_15 = m[mOffset + 15] | 0;

  // ═══════════════════════════════════════════════════════════════════════
  // 🚀 ИНЛАЙНИНГ ФУНКЦИИ round(): 7 раундов в одном цикле
  // ═══════════════════════════════════════════════════════════════════════
  // 
  // Раунд применяет G-функцию ко всем 16 словам состояния.
  // Состояние представлено как матрица 4×4:
  // 
  //   ┌──────┬──────┬──────┬──────┐
  //   │  0   │  1   │  2   │  3   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  4   │  5   │  6   │  7   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  8   │  9   │ 10   │ 11   │
  //   ├──────┼──────┼──────┼──────┤
  //   │ 12   │ 13   │ 14   │ 15   │
  //   └──────┴──────┴──────┴──────┘
  // 
  // Каждый раунд состоит из двух фаз:
  // 
  // 1. СТОЛБЦЫ - G применяется к каждому столбцу:
  //    G(0,4,8,12)  G(1,5,9,13)  G(2,6,10,14)  G(3,7,11,15)
  // 
  // 2. ДИАГОНАЛИ - G применяется к диагоналям:
  //    G(0,5,10,15) G(1,6,11,12) G(2,7,8,13)   G(3,4,9,14)
  // 
  // ───────────────────────────────────────────────────────────────────────
  // ОПТИМИЗАЦИЯ v3: Инлайнинг + плоский массив перестановок
  // ───────────────────────────────────────────────────────────────────────
  // 
  // Вместо 7 вызовов функции round():
  //   round(state, blockWords, ROUND_PERMUTATIONS[0]);
  //   round(state, blockWords, ROUND_PERMUTATIONS[1]);
  //   ... (7 вызовов)
  // 
  // Мы используем один цикл с бегущим указателем p в плоском
  // массиве PERMUTATIONS. Это позволяет избежать:
  // - Накладных расходов на 7 вызовов функции round()
  // - 2D-индексации ROUND_PERMUTATIONS[round][index]
  // - Копирования блока сообщения (без `new Uint32Array(m)`)
  // - Вызова permute() после каждого раунда (без перемещения данных)
  // 
  // Экономия на один вызов compress():
  // - 7 выделений стекового фрейма
  // - 7 × 16 = 112 операций индексации в 2D-массиве
  // - Улучшенная локальность кэша благодаря линейному доступу к PERMUTATIONS
  // 
  // BLAKE2 имеет 10 раундов, BLAKE3 оптимизирован до 7 для скорости.
  // ═══════════════════════════════════════════════════════════════════════
  
  // Используем один цикл с бегущим указателем:
  for (let round = 0; round < 7; ++round) {
    // ─────────────────────────────────────────────────────────────
    // Фаза 1: Перемешивание по столбцам
    // G(0,4,8,12), G(1,5,9,13), G(2,6,10,14), G(3,7,11,15)
    // ─────────────────────────────────────────────────────────────
    // G применяется вертикально к каждому из 4 столбцов.
    //
    // Слова сообщения доступны через m[PERMUTATIONS[p++]], где p
    // автоматически продвигается по плоскому массиву перестановок.

    // G(0, 4, 8, 12) с message_0, message_1
    s_0 = (((s_0 + s_4) | 0) + message_0) | 0;
    s_12 ^= s_0;
    s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_8 = (s_8 + s_12) | 0;
    s_4 ^= s_8;
    s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_0 = (((s_0 + s_4) | 0) + message_1) | 0;
    s_12 ^= s_0;
    s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_8 = (s_8 + s_12) | 0;
    s_4 ^= s_8;
    s_4 = (s_4 >>> 7) | (s_4 << 25);

    // G(1, 5, 9, 13) с message_2, message_3
    s_1 = (((s_1 + s_5) | 0) + message_2) | 0;
    s_13 ^= s_1;
    s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_9 = (s_9 + s_13) | 0;
    s_5 ^= s_9;
    s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_1 = (((s_1 + s_5) | 0) + message_3) | 0;
    s_13 ^= s_1;
    s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_9 = (s_9 + s_13) | 0;
    s_5 ^= s_9;
    s_5 = (s_5 >>> 7) | (s_5 << 25);

    // G(2, 6, 10, 14) с message_4, message_5
    s_2 = (((s_2 + s_6) | 0) + message_4) | 0;
    s_14 ^= s_2;
    s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_10 = (s_10 + s_14) | 0;
    s_6 ^= s_10;
    s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_2 = (((s_2 + s_6) | 0) + message_5) | 0;
    s_14 ^= s_2;
    s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_10 = (s_10 + s_14) | 0;
    s_6 ^= s_10;
    s_6 = (s_6 >>> 7) | (s_6 << 25);

    // G(3, 7, 11, 15) с message_6, message_7
    s_3 = (((s_3 + s_7) | 0) + message_6) | 0;
    s_15 ^= s_3;
    s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_11 = (s_11 + s_15) | 0;
    s_7 ^= s_11;
    s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_3 = (((s_3 + s_7) | 0) + message_7) | 0;
    s_15 ^= s_3;
    s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_11 = (s_11 + s_15) | 0;
    s_7 ^= s_11;
    s_7 = (s_7 >>> 7) | (s_7 << 25);
    
    // ─────────────────────────────────────────────────────────────
    // Фаза 2: Перемешивание по диагоналям
    // G(0,5,10,15), G(1,6,11,12), G(2,7,8,13), G(3,4,9,14)
    // ─────────────────────────────────────────────────────────────
    // G применяется вдоль диагоналей с переносом.
    //
    
    // G(0, 5, 10, 15) с message_8, message_9
    s_0 = (((s_0 + s_5) | 0) + message_8) | 0;
    s_15 ^= s_0;
    s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_10 = (s_10 + s_15) | 0;
    s_5 ^= s_10;
    s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_0 = (((s_0 + s_5) | 0) + message_9) | 0;
    s_15 ^= s_0;
    s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_10 = (s_10 + s_15) | 0;
    s_5 ^= s_10;
    s_5 = (s_5 >>> 7) | (s_5 << 25);

    // G(1, 6, 11, 12) с message_10, message_11
    s_1 = (((s_1 + s_6) | 0) + message_10) | 0;
    s_12 ^= s_1;
    s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_11 = (s_11 + s_12) | 0;
    s_6 ^= s_11;
    s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_1 = (((s_1 + s_6) | 0) + message_11) | 0;
    s_12 ^= s_1;
    s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_11 = (s_11 + s_12) | 0;
    s_6 ^= s_11;
    s_6 = (s_6 >>> 7) | (s_6 << 25);

    // G(2, 7, 8, 13) с message_12, message_13
    s_2 = (((s_2 + s_7) | 0) + message_12) | 0;
    s_13 ^= s_2;
    s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_8 = (s_8 + s_13) | 0;
    s_7 ^= s_8;
    s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_2 = (((s_2 + s_7) | 0) + message_13) | 0;
    s_13 ^= s_2;
    s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_8 = (s_8 + s_13) | 0;
    s_7 ^= s_8;
    s_7 = (s_7 >>> 7) | (s_7 << 25);

    // G(3, 4, 9, 14) с message_14, message_15
    s_3 = (((s_3 + s_4) | 0) + message_14) | 0;
    s_14 ^= s_3;
    s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_9 = (s_9 + s_14) | 0;
    s_4 ^= s_9;
    s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_3 = (((s_3 + s_4) | 0) + message_15) | 0;
    s_14 ^= s_3;
    s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_9 = (s_9 + s_14) | 0;
    s_4 ^= s_9;
    s_4 = (s_4 >>> 7) | (s_4 << 25);
    
    // ─────────────────────────────────────────────────────────────────────
    // Перестановка (кроме последнего раунда)
    // ─────────────────────────────────────────────────────────────────────
    if (round !== 6) {
      const t0 = message_0;
      const t1 = message_1;
      message_0 = message_2;
      message_2 = message_3;
      message_3 = message_10;
      message_10 = message_12;
      message_12 = message_9;
      message_9 = message_11;
      message_11 = message_5;
      message_5 = t0;
      message_1 = message_6;
      message_6 = message_4;
      message_4 = message_7;
      message_7 = message_13;
      message_13 = message_14;
      message_14 = message_15;
      message_15 = message_8;
      message_8 = t1;
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // Финализация 
  // XOR верхней и нижней половин состояния
  //
  // Это "сжимает" 512 бит до 256 бит и добавляет прямую связь
  // Запись в out вместо return
  //
  // Порядок записи КРИТИЧЕН для in-place корректности!
  // Если out === cv и outOffset === cvOffset, то запись в out[0]
  // уничтожит cv[0] до того, как мы его прочитаем для out[8].
  // Поэтому сначала пишем старшую половину (8-15), потом младшую (0-7).
  // ═══════════════════════════════════════════════════════════════════════
  if (!truncate) {
    // Расширенный вывод (XOF) — нужны все 16 слов
    out[outOffset + 8] = s_8 ^ cv[cvOffset + 0];
    out[outOffset + 9] = s_9 ^ cv[cvOffset + 1];
    out[outOffset + 10] = s_10 ^ cv[cvOffset + 2];
    out[outOffset + 11] = s_11 ^ cv[cvOffset + 3];
    out[outOffset + 12] = s_12 ^ cv[cvOffset + 4];
    out[outOffset + 13] = s_13 ^ cv[cvOffset + 5];
    out[outOffset + 14] = s_14 ^ cv[cvOffset + 6];
    out[outOffset + 15] = s_15 ^ cv[cvOffset + 7];
  }
  
  // Младшая половина — chaining value для следующего блока
  out[outOffset + 0] = s_0 ^ s_8;
  out[outOffset + 1] = s_1 ^ s_9;
  out[outOffset + 2] = s_2 ^ s_10;
  out[outOffset + 3] = s_3 ^ s_11;
  out[outOffset + 4] = s_4 ^ s_12;
  out[outOffset + 5] = s_5 ^ s_13;
  out[outOffset + 6] = s_6 ^ s_14;
  out[outOffset + 7] = s_7 ^ s_15;
}


// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * Читает байты как little-endian 32-битные слова.
 * 
 * Little-endian означает, что младший байт идёт первым.
 * Пример: байты [0x78, 0x56, 0x34, 0x12] → слово 0x12345678
 */
 
 /**
 * Быстрое чтение полного блока (64 байта) без проверок границ.
 * 
 * @param {Uint8Array}  array       - входной массив байтов
 * @param {number}      offset      - начальная позиция чтения
 * @param {Uint32Array} words       - выходной массив слов
 * @param {number}      wordsOffset - позиция записи в выходном массиве
 */
// ═══════════════════════════════════════════════════════════════════════════
// ✅ ОПТИМИЗАЦИЯ: Две версии функции чтения
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Быстрое чтение полного блока (64 байта).
 * Без проверок границ - для 99% вызовов.
 */
function readLittleEndianWordsFull(array, offset, words, wordsOffset) {
  for (let i = 0; i < 16; ++i, offset += 4) {
    words[wordsOffset + i] = // Теперь пишем с учётом смещения
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
}

/**
 * Чтение неполного блока с padding.
 * Только для последнего блока данных.
 */
 /**
 * Функция обрабатывает неполные блоки с дополнением нулями (padding).
 * Используется только для последнего блока данных.
 * 
 * @param {Uint8Array}  array       - входной массив байтов
 * @param {number}      offset      - начальная позиция чтения
 * @param {number}      length      - общая длина данных (для определения границы)
 * @param {Uint32Array} words       - выходной массив слов
 * @param {number}      wordsOffset - позиция записи в выходном массиве
 */
function readLittleEndianWordsPartial(array, offset, length, words, wordsOffset) {
  // Заполняем нулями
  for (let i = 0; i < 16; ++i) {
    words[wordsOffset + i] = 0;
  }
  
  let i = 0;
  // Полные 4-байтные слова
  for (; offset + 3 < length && i < 16; ++i, offset += 4) {
    words[wordsOffset + i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
  
  // Оставшиеся байты
  for (let s = 0; offset < length; s += 8, ++offset) {
    words[wordsOffset + i] |= array[offset] << s;
  }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

/**
 * Вычисляет BLAKE3 хэш входных данных.
 * 
 * Алгоритм работает в три этапа:
 * 
 * 1. ОБРАБОТКА ПОЛНЫХ ЧАНКОВ (по 1024 байта):
 *    - Каждый чанк состоит из 16 блоков по 64 байта
 *    - Блоки цепочкой сжимаются в одно 256-битное значение
 *    - Результаты чанков складываются в стек для дерева Меркла
 * 
 * 2. ОБРАБОТКА ПОСЛЕДНЕГО (НЕПОЛНОГО) ЧАНКА:
 *    - Может содержать от 0 до 1023 байт
 *    - Паддится нулями до границы блока
 * 
 * 3. ПОСТРОЕНИЕ ДЕРЕВА МЕРКЛА:
 *    - Пары узлов объединяются в родительские узлы
 *    - Повторяется до получения единственного корня
 *    - Корень хэшируется с флагом ROOT
 * 
 * Визуализация дерева для 4 чанков:
 * 
 *              ROOT
 *             /    \
 *        PARENT    PARENT
 *        /   \     /    \
 *     CV0   CV1  CV2   CV3
 *      |     |    |     |
 *   Chunk0 Chunk1 Chunk2 Chunk3
 * 
 * @param {Uint8Array} input - входные данные
 * @returns {Uint8Array} - хэш (32 байта)
 */
function blake3(input) {
  // Проверка типа входных данных
  if (!(input instanceof Uint8Array)) {
    throw new Error('Input must be Uint8Array');
  }

  // Инициализация
  const flags = 0;                    // Базовые флаги (можно добавить KEYED_HASH и др.)
  const length = input.length;

  // ═════════════════════════════════════════════════════════════════════
  // Создаём Uint32Array view на входные данные (ОДИН РАЗ перед циклами)
  // На Little-Endian это даёт прямой доступ без копирования
  // ═════════════════════════════════════════════════════════════════════
    const canUseDirectView = !IsBigEndian && (input.byteOffset % 4 === 0);
    const inputWords = canUseDirectView ? new Uint32Array(
      input.buffer,
      input.byteOffset,
      input.byteLength >> 2
    ) : null;

  const cvStack = getCvStack(length);  // Может переиспользовать существующий
  let cvStackPos = 0;

  const workBuffer = globalWorkBuffer;  // Всегда переиспользуем
  const CV_OFFSET = 0;
  const BLOCK_OFFSET = 8;

  // Инициализация CV = IV
  workBuffer.set(IV, CV_OFFSET);

  let chunkCounter = 0;               // Счётчик обработанных чанков
  let offset = 0;                     // Текущая позиция во входных данных
  
  // Вычисляем, сколько полных чанков обработать
  // take = наибольшее число, кратное 1024, которое < length
  let take = length - (length % 1024);
  if (take === length && length > 0) { 
    // Если длина кратна 1024, последний чанк все равно обрабатывается отдельно (как partial),
    // или как полный, но с флагом CHUNK_END. 
    // В оригинальной логике take должен быть меньше length, если length > 0.
    take -= 1024;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 1: Обработка полных чанков (по 1024 байта = 16 блоков)
  // ═══════════════════════════════════════════════════════════════════════
  
  for (; offset < take; ) {
    // Сбросить CV в IV для нового чанка
    workBuffer.set(IV, CV_OFFSET);

    // Обрабатываем 16 блоков чанка
    for (let i = 0; i < 16; ++i, offset += 64) {
      // ═══════════════════════════════════════════════════════════════════
      // v8: Little-Endian оптимизация — Zero-Copy!
      // ═══════════════════════════════════════════════════════════════
      if (!canUseDirectView) {
        // Если big-Endian, то нужно преобразование байтов
        readLittleEndianWordsFull(input, offset, workBuffer, BLOCK_OFFSET);  // ✅ Быстрая версияread
      }
      // В остальных случаях нотация - little-endian и 
      // тогда читаем напрямую из inputWords — никакого копирования!

      // Определяем флаги для блока:
      // - Первый блок: CHUNK_START
      // - Последний блок (15-й): CHUNK_END
      // - Остальные: без флагов
      compress(
        workBuffer, CV_OFFSET,      // cv
        // block: workBuffer или напрямую input
        canUseDirectView ? inputWords : workBuffer,      // ← прямой доступ!
        // смещение: в workBuffer или в inputWords
        canUseDirectView ? (offset >> 2): BLOCK_OFFSET,  // ← смещение в словах   
        workBuffer, CV_OFFSET,      // out = записать обратно в CV
        true,                       // truncate
        chunkCounter,
        BLOCK_LEN,
        flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
      );
    }

    // Push CV в стек. Добавляем результат чанка в стек
    cvStack.set(workBuffer.subarray(CV_OFFSET, CV_OFFSET + 8), cvStackPos);
    cvStackPos += 8;
    chunkCounter += 1;

    // Объединяем узлы дерева Меркла, пока можем
    // (пока количество чанков кратно 2)
    let totalChunks = chunkCounter;
    while ((totalChunks & 1) === 0) {
      // Извлекаем два дочерних узла
      cvStackPos -= 16;  // "Pop" два элемента - просто сдвиг числа!
      
      // Сжимаем с флагом PARENT
      // Два CV уже лежат рядом в cvStack — используем как blockWords!
      compress(
        IV, 0,                    // cv = IV (для parent node)
        cvStack, cvStackPos,      // m = два CV, уже лежащих рядом!
        cvStack, cvStackPos,      // out = записать результат туда же
        true,                     // truncate = нужны только 8 слов
        0, BLOCK_LEN, 
        flags | PARENT
      );
      
      // Добавить в массив
      cvStackPos += 8;   // "Push" один элемент - результат уже на месте!

      totalChunks >>= 1;
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 2: Обработка последнего (возможно неполного) чанка
  // ═══════════════════════════════════════════════════════════════════════

  const remainingBytes = length - take;
  const fullBlocks = remainingBytes > 0 ? ((remainingBytes - 1) / 64) | 0 : 0;

  // Сбросить CV в IV
  workBuffer.set(IV, CV_OFFSET);

  // Обрабатываем полные блоки последнего чанка
  for (let i = 0; i < fullBlocks; ++i, offset += 64) {
    if (!canUseDirectView) {
      // Если big-Endian, то нужно преобразование байтов
      readLittleEndianWordsFull(input, offset, workBuffer, BLOCK_OFFSET);  // ✅ Быстрая версия
    }

    compress(
      workBuffer, CV_OFFSET,
      // block: workBuffer или напрямую input
      canUseDirectView ? inputWords : workBuffer, 
      // смещение: в workBuffer или в inputWords
      canUseDirectView ? (offset >> 2) : BLOCK_OFFSET,
      workBuffer, CV_OFFSET,
      true,
      chunkCounter,
      BLOCK_LEN,
      flags | (i === 0 ? CHUNK_START : 0)
    );
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 3: Финализация - обработка последнего блока и построение корня
  // ═══════════════════════════════════════════════════════════════════════

  let finalChainingValue;
  let finalBlockLen;
  let finalFlags;

  // Читаем последний блок (может быть неполным)
  readLittleEndianWordsPartial(input, offset, length, workBuffer, BLOCK_OFFSET);  // ✅ С проверками границ
  const lastBlockLen = length - offset;

  if (cvStackPos === 0) {
    // Особый случай: все данные помещаются в один чанк
    // Финальный блок - это и корень дерева
    // Все данные в одном чанке — сразу вычисляем ROOT
    compress(
      workBuffer, CV_OFFSET,
      workBuffer, BLOCK_OFFSET,
      workBuffer, CV_OFFSET,
      true,
      chunkCounter,
      lastBlockLen,
      flags | ROOT | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0)
    );
  } else {
    // Общий случай: нужно построить дерево Меркла

    // Завершаем последний чанк
    compress(
      workBuffer, CV_OFFSET,
      workBuffer, BLOCK_OFFSET,
      cvStack, cvStackPos,  // Push результат в стек
      true,
      chunkCounter,
      lastBlockLen,
      flags | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0)
    );
    cvStackPos += 8;

    // Объединяем оставшиеся узлы в дерево
    while (cvStackPos > 16) {
      cvStackPos -= 16;
      compress(
        IV, 0,
        cvStack, cvStackPos,
        cvStack, cvStackPos,
        true,
        0,
        BLOCK_LEN,
        flags | PARENT
      );
      cvStackPos += 8;
    }

    // Финальное слияние с флагом ROOT
    cvStackPos -= 16;
    compress(
      IV, 0,
      cvStack, cvStackPos,
      workBuffer, CV_OFFSET,  // Результат в workBuffer
      true,
      0,
      BLOCK_LEN,
      flags | PARENT | ROOT
    );
  }
  // Возвращаем первые 32 байта (256 бит) как хэш
  return new Uint8Array(workBuffer.buffer, CV_OFFSET * 4, 32);
}
const hash = blake3;


// ============================================================================
// ЭКСПОРТ
// ============================================================================

export { blake3 };
export { hash };

/*
┌─────────────────────────────────────────────────────────────────┐
│                         ВХОДНЫЕ ДАННЫЕ                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Разбиение на ЧАНКИ (1024 байта = 16 блоков по 64 байта)        │
└─────────────────────────────────────────────────────────────────┘
                              │
            ┌─────────────────┼─────────────────┐
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │ Chunk 0 │       │ Chunk 1 │       │ Chunk N │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │   CV0   │       │   CV1   │       │   CVN   │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            └────────┬────────┴────────┬────────┘
                     ▼                 ▼
                ┌─────────┐       ┌─────────┐
                │ PARENT  │       │ PARENT  │
                └────┬────┘       └────┬────┘
                     └────────┬────────┘
                              ▼
                         ┌─────────┐
                         │  ROOT   │
                         └────┬────┘
                              │
                              ▼
                   ┌───────────────────┐
                   │   HASH (32 bytes) │
                   └───────────────────┘
*/
