/**
 * ============================================================================
 * BLAKE3 - Naive JavaScript Implementation (Working v3)
 * ============================================================================
 * 
 * BLAKE3 - это криптографическая хэш-функция, разработанная в 2020 году.
 * Она объединяет лучшие качества BLAKE2 и Bao (параллельное дерево Меркла).
 * 
 * Основные характеристики:
 * - Размер блока: 64 байта
 * - Размер чанка: 1024 байта (16 блоков)
 * - Размер вывода: 32 байта (по умолчанию), но поддерживает XOF
 * - Количество раундов: 7 (вместо 10 в BLAKE2s)
 * 
 * Структура алгоритма:
 * 1. Входные данные разбиваются на чанки по 1024 байта
 * 2. Каждый чанк обрабатывается как цепочка из 16 блоков по 64 байта
 * 3. Результаты чанков объединяются в дерево Меркла
 * 4. Корень дерева даёт финальный хэш
 * 
 * Вход:  Uint8Array (любой длины)
 * Выход: Uint8Array (32 байта)
 */

/**
 * ============================================================================
 * BLAKE3 v3 - Инлайнинг round() в compress()
 * ============================================================================
 * 
 * Оптимизации в этой версии:
 * - v1: readLittleEndianWordsFull (без проверок границ)
 * - v2: Встроенные перестановки (без копирования массива, предвычисленный порядок доступа)
 * - v3: Инлайнинг round() в compress() + плоский массив перестановок
 *       Результат: ускорение ~1.1x (с 99 с до 89 мс на 1 МБ данных)
 */

// ============================================================================
// КОНСТАНТЫ
// ============================================================================

/**
 * Вектор инициализации (IV) - первые 32 бита дробной части 
 * квадратных корней первых 8 простых чисел: √2, √3, √5, √7, √11, √13, √17, √19
 * 
 * Эти же константы используются в SHA-256 и BLAKE2s.
 * Они выбраны как "nothing-up-my-sleeve numbers" - числа, которые
 * невозможно подобрать специально для создания backdoor.
 */
const IV = new Uint32Array([
  0x6a09e667,  // √2
  0xbb67ae85,  // √3
  0x3c6ef372,  // √5
  0xa54ff53a,  // √7
  0x510e527f,  // √11
  0x9b05688c,  // √13
  0x1f83d9ab,  // √17
  0x5be0cd19,  // √19
]);

/**
 * Флаги домена - указывают тип обрабатываемого блока.
 * Используются для domain separation (разделения доменов),
 * чтобы одинаковые данные в разных контекстах давали разные хэши.
 */
const CHUNK_START = 1;   // 0b0001 - первый блок в чанке
const CHUNK_END = 2;     // 0b0010 - последний блок в чанке
const PARENT = 4;        // 0b0100 - родительский узел в дереве Меркла
const ROOT = 8;          // 0b1000 - корневой узел (финальный хэш)
// Также существуют: KEYED_HASH = 16, DERIVE_KEY_CONTEXT = 32, DERIVE_KEY_MATERIAL = 64

/**
 * Размер блока в байтах.
 * BLAKE3 обрабатывает данные блоками по 64 байта = 16 слов по 4 байта.
 */
const BLOCK_LEN = 64;

/**
 * Предвычисленные индексы перестановок в плосском массиве для всех 7 раундов.
 * 
 * Вместо физического перемещения данных в массиве сообщения после каждого раунда
 * (что требует создания временной копии), мы предвычисляем ПОРЯДОК ДОСТУПА
 * к исходным данным для каждого раунда.
 * 
 * Принцип работы:
 * - Оригинальный подход: permute(m) копирует массив и перетасовывает данные после каждого раунда
 * - Оптимизированный подход v2: обращаемся к m[ROUND_PERMUTATIONS[round][i]] с предвычисленными индексами
 * - Оптимизированный подход v3: обращаемся к PERMUTATIONS[r * 16 + i], где раунд r, индекс i (плоский массив + бегущий указатель)
 * 
 * Преимущества плоского Uint8Array перед двумерным Array[][]:
 * - Линейное хранение в памяти → лучшая локальность кэша (cache locality)
 * - Простая арифметика адресации: p++ вместо [round][index]
 * - Uint8Array хранится в непрерывной области → идеально для CPU prefetcher
 * - Индексы 0-15 умещаются в байт → компактность (112 байт vs ~900+ для Array)
 * - JIT-компилятор видит последовательный паттерн доступа
 * 
 * Экономия памяти на каждый вызов compress():
 * - Без оптимизации: 7 × 64 байта = 448 байт аллоцируется (копии массива m)
 * - С оптимизацией: 0 байт аллоцируется (только чтение из статического массива)
 * 
 * Размер: 7 раундов × 16 индексов = 112 элементов
 * Адресация: раунд r, индекс i → PERMUTATIONS[r * 16 + i]
 * (но мы используем бегущий указатель p++ для ещё большей эффективности)
 * 
 /**
 * Плоский массив перестановок для 7 раундов.
 * 
 * Линейное хранение: раунд r, индекс i → PERMUTATIONS[r * 16 + i]
 * Использование Uint8Array обеспечивает компактность и cache-friendliness.
 */
const PERMUTATIONS = new Uint8Array([
  // Раунд 1: тождественная
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  // Раунд 2
  2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8,
  // Раунд 3
  3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1,
  // Раунд 4
  10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6,
  // Раунд 5
  12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4,
  // Раунд 6
  9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7,
  // Раунд 7
  11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13,
]);

// ============================================================================
// БАЗОВЫЕ ОПЕРАЦИИ
// ============================================================================

/**
 * Циклический сдвиг вправо (rotate right).
 * 
 * В отличие от обычного сдвига (>>), биты не теряются,
 * а переходят с правого края на левый.
 * 
 * Пример для 8 бит: rightRotate(0b11110000, 2) = 0b00111100
 * 
 * @param {number} word - 32-битное слово
 * @param {number} bits - количество позиций для сдвига
 * @returns {number} - результат циклического сдвига
 * 
 * Примечание: НЕ используем >>> 0 в конце, так как побитовые операции
 * в JavaScript автоматически приводят результат к 32-битному целому.
 */
function rightRotate(word, bits) {
  return (word >>> bits) | (word << (32 - bits));
}

/**
 * G-функция v3 - сердце BLAKE3 (самостоятельная).
 * 
 * Это четвертьраундовая функция (quarter-round), которая смешивает
 * 4 слова состояния (a, b, c, d) с двумя словами сообщения (mx, my).
 * 
 * Схема работы (ARX - Add-Rotate-XOR):
 * 
 *   a ← a + b + mx
 *   d ← (d ⊕ a) >>> 16
 *   c ← c + d
 *   b ← (b ⊕ c) >>> 12
 *   a ← a + b + my
 *   d ← (d ⊕ a) >>> 8
 *   c ← c + d
 *   b ← (b ⊕ c) >>> 7
 * 
 * Константы ротации (16, 12, 8, 7) оптимизированы для 32-битных слов.
 *
 * Теперь функция сама определяет, какие слова сообщения использовать,
 * обращаясь к глобальной таблице перестановок по переданным индексам.
 * 
 * @param {Uint32Array} state - 16-словное состояние
 * @param {Uint32Array} m - блок сообщения (16 слов, неизменяемый)
 * @param {number} x - индекс в таблице PERMUTATIONS для первого слова
 * @param {number} y - индекс в таблице PERMUTATIONS для второго слова
 * @param {number} a,b,c,d - индексы смешиваемых слов состояния
 */
function g(state, m, x, y, a, b, c, d) {
  const mx = m[PERMUTATIONS[x]];  // Самостоятельный доступ
  const my = m[PERMUTATIONS[y]];  // к нужным словам
  
  // ARX-преобразование остаётся неизменным
  // Первая половина: подмешиваем mx
  state[a] = (((state[a] + state[b]) | 0) + mx) | 0;  // a ← a + b + mx
  state[d] = rightRotate(state[d] ^ state[a], 16);    // d ← (d ⊕ a) >>> 16
  state[c] = (state[c] + state[d]) | 0;               // c ← c + d
  state[b] = rightRotate(state[b] ^ state[c], 12);    // b ← (b ⊕ c) >>> 12
  
  // Вторая половина: подмешиваем my
  state[a] = (((state[a] + state[b]) | 0) + my) | 0;  // a ← a + b + my
  state[d] = rightRotate(state[d] ^ state[a], 8);     // d ← (d ⊕ a) >>> 8
  state[c] = (state[c] + state[d]) | 0;               // c ← c + d
  state[b] = rightRotate(state[b] ^ state[c], 7);     // b ← (b ⊕ c) >>> 7
}


// ============================================================================
// ФУНКЦИЯ СЖАТИЯ
// ============================================================================

/**
 * Функция сжатия - основная криптографическая операция BLAKE3.
 * 
 * Принимает:
 * - chainingValue: 8 слов (256 бит) - результат предыдущего сжатия или IV
 * - blockWords: 16 слов (512 бит) - блок данных
 * - counter: 64-битный счётчик чанков
 * - blockLen: длина блока в байтах (для паддинга)
 * - flags: флаги домена
 * 
 * Возвращает: 16 слов (512 бит) - результат сжатия
 * 
 * Начальное состояние (16 слов = 512 бит):
 * 
 *   ┌─────────────────────────────────────────────────┐
 *   │  h0    h1    h2    h3   ← chaining value (0-3)  │
 *   │  h4    h5    h6    h7   ← chaining value (4-7)  │
 *   │ IV0   IV1   IV2   IV3   ← константы IV          │
 *   │  t0    t1  blen  flags  ← counter, len, flags   │
 *   └─────────────────────────────────────────────────┘
 * 
 * @param {Uint32Array} chainingValue - входное сцепляющее значение (8 слов)
 * @param {Uint32Array} blockWords - блок сообщения (16 слов)
 * @param {number} counter - номер чанка (младшие 32 бита)
 * @param {number} blockLen - длина данных в блоке
 * @param {number} flags - флаги домена
 * @returns {Uint32Array} - результат сжатия (16 слов)
 */
function compress(chainingValue, blockWords, counter, blockLen, flags) {
  // Инициализация состояния
  const state = new Uint32Array([
    // Строки 0-1: сцепляющее значение (результат предыдущего блока или IV)
    chainingValue[0], chainingValue[1], chainingValue[2], chainingValue[3],
    chainingValue[4], chainingValue[5], chainingValue[6], chainingValue[7],
    // Строка 2: константы IV
    IV[0], IV[1], IV[2], IV[3],
    // Строка 3: счётчик (64 бита), длина блока, флаги
    counter,                      // t0: младшие 32 бита счётчика
    (counter / 0x100000000) | 0,  // t1: старшие 32 бита (counter >> 32)
    blockLen,                     // длина данных в блоке
    flags,                        // флаги домена
  ]);

  // Старт инлайтинга функции round()
  // ═══════════════════════════════════════════════════════════════════════
  // 🚀 ИНЛАЙНИНГ ФУНКЦИИ round(): 7 раундов в одном цикле
  // ═══════════════════════════════════════════════════════════════════════
  // 
  // Раунд применяет G-функцию ко всем 16 словам состояния.
  // Состояние представляется как матрица 4×4:
  // 
  //   ┌──────┬──────┬──────┬──────┐
  //   │  0   │  1   │  2   │  3   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  4   │  5   │  6   │  7   │
  //   ├──────┼──────┼──────┼──────┤
  //   │  8   │  9   │ 10   │ 11   │
  //   ├──────┼──────┼──────┼──────┤
  //   │ 12   │ 13   │ 14   │ 15   │
  //   └──────┴──────┴──────┴──────┘
  // 
  // Каждый раунд состоит из двух фаз:
  // 
  // 1. КОЛОНКИ - G применяется к каждой колонке:
  //    G(0,4,8,12)  G(1,5,9,13)  G(2,6,10,14)  G(3,7,11,15)
  // 
  // 2. ДИАГОНАЛИ - G применяется к диагоналям:
  //    G(0,5,10,15) G(1,6,11,12) G(2,7,8,13)   G(3,4,9,14)
  // 
  // ───────────────────────────────────────────────────────────────────────
  // ОПТИМИЗАЦИЯ v3: Инлайнинг + плоский массив перестановок
  // ───────────────────────────────────────────────────────────────────────
  // 
  // Вместо 7 вызовов функции round():
  //   round(state, blockWords, ROUND_PERMUTATIONS[0]);
  //   round(state, blockWords, ROUND_PERMUTATIONS[1]);
  //   ... (7 вызовов)
  // 
  // Используем единый цикл с бегущим указателем p в плоском массиве
  // PERMUTATIONS. Это позволяет избежать:
  // - Накладных расходов на 7 вызовов функции round()
  // - Двумерной индексации ROUND_PERMUTATIONS[round][index]
  // - Копирования блока сообщения (без `new Uint32Array(m)`)
  // - Вызова permute() после каждого раунда (без перемещения данных)
  // 
  // Экономия на каждый вызов compress():
  // - 7 аллокаций стековых фреймов
  // - 7 × 16 = 112 операций индексации в двумерном массиве
  // - Улучшенная локальность кэша благодаря линейному доступу к PERMUTATIONS
  // 
  // В BLAKE2 - 10 раундов, BLAKE3 оптимизирован до 7 для скорости.
  // ═══════════════════════════════════════════════════════════════════════
  
  // Используем единый цикл с бегущим указателем:
  let p = 0;  // Указатель в плоском массиве PERMUTATIONS
  
  for (let round = 0; round < 7; ++round) {
    // ─────────────────────────────────────────────────────────────
    // Фаза 1: Смешивание колонок (column mixing)
    // ─────────────────────────────────────────────────────────────
    // G применяется вертикально к каждой из 4 колонок:
    //   
    //   ┌──────┬──────┬──────┬──────┐
    //   │  ↓   │  ↓   │  ↓   │  ↓   │  
    //   ├──────┼──────┼──────┼──────┤
    //   │  ↓   │  ↓   │  ↓   │  ↓   │
    //   ├──────┼──────┼──────┼──────┤
    //   │  ↓   │  ↓   │  ↓   │  ↓   │
    //   ├──────┼──────┼──────┼──────┤
    //   │  ↓   │  ↓   │  ↓   │  ↓   │
    //   └──────┴──────┴──────┴──────┘
    //
    // Доступ к словам сообщения через m[PERMUTATIONS[p++]], где p
    // автоматически продвигается по плоскому массиву перестановок.

    g(state, blockWords, p++, p++, 0, 4,  8, 12);  // Колонка 0
    g(state, blockWords, p++, p++, 1, 5,  9, 13);  // Колонка 1
    g(state, blockWords, p++, p++, 2, 6, 10, 14);  // Колонка 2
    g(state, blockWords, p++, p++, 3, 7, 11, 15);  // Колонка 3
    
    // ─────────────────────────────────────────────────────────────
    // Фаза 2: Смешивание диагоналей (diagonal mixing)
    // ─────────────────────────────────────────────────────────────
    // G применяется по диагоналям с wrap-around (циклический перенос):
    //
    //   ┌──────┬──────┬──────┬──────┐
    //   │  ↘  │   ↘ │     │↘     │ 
    //   ├──────┼──────┼──────┼──────┤ 
    //   │      │  ↘  │   ↘ │      │
    //   ├──────┼──────┼──────┼──────┤
    //   │      │      │ ↘   │   ↘ │
    //   ├──────┼──────┼──────┼──────┤
    //   │   ↘ │      │      │  ↘  │
    //   └──────┴──────┴──────┴──────┘
    //
    g(state, blockWords, p++, p++, 0, 5, 10, 15);  // Диагональ 0
    g(state, blockWords, p++, p++, 1, 6, 11, 12);  // Диагональ 1
    g(state, blockWords, p++, p++, 2, 7,  8, 13);  // Диагональ 2
    g(state, blockWords, p++, p++, 3, 4,  9, 14);  // Диагональ 3
  }
  // Конец инлайтинга функции round()

  // Финализация: XOR верхней и нижней половин состояния
  // Это "сжимает" 512 бит до 256 бит и добавляет feed-forward
  for (let i = 0; i < 8; ++i) {
    state[i] ^= state[i + 8];           // out[i] = state[i] ⊕ state[i+8]
    state[i + 8] ^= chainingValue[i];   // out[i+8] = state[i+8] ⊕ h[i]
  }

  return state;
}

/**
 * Извлекает первые 8 слов (256 бит) из результата сжатия.
 * 
 * Это "сцепляющее значение" (chaining value), которое передаётся
 * в следующий блок или используется как узел дерева Меркла.
 * 
 * @param {Uint32Array} compressionOutput - результат compress (16 слов)
 * @returns {Uint32Array} - первые 8 слов (новый массив)
 */
function first8Words(compressionOutput) {
  return new Uint32Array(compressionOutput).slice(0, 8);
}

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * Читает байты как little-endian 32-битные слова.
 * 
 * Little-endian означает, что младший байт идёт первым.
 * Пример: байты [0x78, 0x56, 0x34, 0x12] → слово 0x12345678
 * 
 * Функция также обрабатывает неполные блоки (паддинг нулями).
 * 
 * @param {Uint8Array} array - входные байты
 * @param {number} offset - начальная позиция
 * @param {Uint32Array} words - массив для записи слов (16 элементов)
 */
// ═══════════════════════════════════════════════════════════════════════════
// ✅ ОПТИМИЗАЦИЯ: Две версии функции чтения
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Быстрое чтение полного блока (64 байта).
 * Без проверок границ - для 99% вызовов.
 */
function readLittleEndianWordsFull(array, offset, words) {
  for (let i = 0; i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
}

/**
 * Чтение неполного блока с padding.
 * Только для последнего блока данных.
 */
function readLittleEndianWordsPartial(array, offset, words) {
  let i = 0;
  for (; offset + 3 < array.length && i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
  for (let j = i; j < 16; ++j) words[j] = 0;
  for (let s = 0; offset < array.length; s += 8, ++offset) {
    words[i] |= array[offset] << s;
  }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

/**
 * Вычисляет BLAKE3 хэш входных данных.
 * 
 * Алгоритм работает в три этапа:
 * 
 * 1. ОБРАБОТКА ПОЛНЫХ ЧАНКОВ (по 1024 байта):
 *    - Каждый чанк состоит из 16 блоков по 64 байта
 *    - Блоки цепочкой сжимаются в одно 256-битное значение
 *    - Результаты чанков складываются в стек для дерева Меркла
 * 
 * 2. ОБРАБОТКА ПОСЛЕДНЕГО (НЕПОЛНОГО) ЧАНКА:
 *    - Может содержать от 0 до 1023 байт
 *    - Паддится нулями до границы блока
 * 
 * 3. ПОСТРОЕНИЕ ДЕРЕВА МЕРКЛА:
 *    - Пары узлов объединяются в родительские узлы
 *    - Повторяется до получения единственного корня
 *    - Корень хэшируется с флагом ROOT
 * 
 * Визуализация дерева для 4 чанков:
 * 
 *              ROOT
 *             /    \
 *        PARENT    PARENT
 *        /   \     /    \
 *     CV0   CV1  CV2   CV3
 *      |     |    |     |
 *   Chunk0 Chunk1 Chunk2 Chunk3
 * 
 * @param {Uint8Array} input - входные данные
 * @returns {Uint8Array} - хэш (32 байта)
 */
function blake3(input) {
  // Проверка типа входных данных
  if (!(input instanceof Uint8Array)) {
    throw new Error('Input must be Uint8Array');
  }

  // Инициализация
  const flags = 0;                    // Базовые флаги (можно добавить KEYED_HASH и др.)
  const keyWords = IV;                // Ключ (IV для обычного хэширования)
  const blockWords = new Uint32Array(16);  // Буфер для блока
  const cvStack = [];                 // Стек для дерева Меркла

  let chunkCounter = 0;               // Счётчик обработанных чанков
  let offset = 0;                     // Текущая позиция во входных данных

  const length = input.length;
  
  // Вычисляем, сколько полных чанков обработать
  // take = наибольшее число, кратное 1024, которое < length
  let take = length - (length % 1024);
  if (take === length && length > 0) { 
    // Если длина кратна 1024, последний чанк все равно обрабатывается отдельно (как partial),
    // или как полный, но с флагом CHUNK_END. 
    // В оригинальной логике take должен быть меньше length, если length > 0.
    take -= 1024;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 1: Обработка полных чанков (по 1024 байта = 16 блоков)
  // ═══════════════════════════════════════════════════════════════════════
  
  for (; offset < take; ) {
    let cv = keyWords;  // Сцепляющее значение (начинаем с IV)

    // Обрабатываем 16 блоков чанка
    for (let i = 0; i < 16; ++i, offset += 64) {
      readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

      // Определяем флаги для блока:
      // - Первый блок: CHUNK_START
      // - Последний блок (15-й): CHUNK_END
      // - Остальные: без флагов
      cv = first8Words(
        compress(
          cv,
          blockWords,
          chunkCounter,
          BLOCK_LEN,
          flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
        )
      );
    }

    chunkCounter += 1;
    cvStack.push(cv);  // Добавляем результат чанка в стек

    // Объединяем узлы дерева Меркла, пока можем
    // (пока количество чанков кратно 2)
    let totalChunks = chunkCounter;
    while ((totalChunks & 1) === 0) {
      // Извлекаем два дочерних узла
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      
      // Формируем блок для родительского узла:
      // левый потомок (8 слов) + правый потомок (8 слов) = 16 слов
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      
      // Сжимаем с флагом PARENT
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
      
      totalChunks >>= 1;
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 2: Обработка последнего (возможно неполного) чанка
  // ═══════════════════════════════════════════════════════════════════════

  const remainingBytes = length - take;
  const fullBlocks = remainingBytes > 0 ? ((remainingBytes - 1) / 64) | 0 : 0;

  let cv = keyWords;

  // Обрабатываем полные блоки последнего чанка
  for (let i = 0; i < fullBlocks; ++i, offset += 64) {
    readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        BLOCK_LEN,
        flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
      )
    );
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 3: Финализация - обработка последнего блока и построение корня
  // ═══════════════════════════════════════════════════════════════════════

  let finalChainingValue;
  let finalBlockLen;
  let finalFlags;

  // Читаем последний блок (может быть неполным)
  readLittleEndianWordsPartial(input, offset, blockWords);  // ✅ С проверками границ

  if (cvStack.length === 0) {
    // Особый случай: все данные помещаются в один чанк
    // Финальный блок - это и корень дерева
    finalChainingValue = cv;
    finalBlockLen = length - offset;
    finalFlags = flags | ROOT | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0);
  } else {
    // Общий случай: нужно построить дерево Меркла
    finalChainingValue = keyWords;
    finalBlockLen = BLOCK_LEN;
    finalFlags = flags | PARENT | ROOT;

    // Завершаем последний чанк
    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        length - offset,
        flags | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0)
      )
    );

    cvStack.push(cv);

    // Объединяем оставшиеся узлы в дерево
    while (cvStack.length > 2) {
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
    }

    // Подготавливаем финальный блок из двух последних узлов
    const rightChildCv = cvStack.pop();
    const leftChildCv = cvStack.pop();
    blockWords.set(leftChildCv, 0);
    blockWords.set(rightChildCv, 8);
  }

  // Финальное сжатие с флагом ROOT
  const out = compress(
    finalChainingValue,
    blockWords,
    0,
    finalBlockLen,
    finalFlags
  );

  // Возвращаем первые 32 байта (256 бит) как хэш
  return new Uint8Array(out.buffer, 0, 32);
}
const hash = blake3;


// ============================================================================
// ЭКСПОРТ
// ============================================================================

export { blake3 };
export { hash };

/*
┌─────────────────────────────────────────────────────────────────┐
│                         ВХОДНЫЕ ДАННЫЕ                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Разбиение на ЧАНКИ (1024 байта = 16 блоков по 64 байта)        │
└─────────────────────────────────────────────────────────────────┘
                              │
            ┌─────────────────┼─────────────────┐
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │ Chunk 0 │       │ Chunk 1 │       │ Chunk N │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │   CV0   │       │   CV1   │       │   CVN   │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            └────────┬────────┴────────┬────────┘
                     ▼                 ▼
                ┌─────────┐       ┌─────────┐
                │ PARENT  │       │ PARENT  │
                └────┬────┘       └────┬────┘
                     └────────┬────────┘
                              ▼
                         ┌─────────┐
                         │  ROOT   │
                         └────┬────┘
                              │
                              ▼
                   ┌───────────────────┐
                   │   HASH (32 bytes) │
                   └───────────────────┘
*/
