/**
 * ============================================================================
 * BLAKE3 - Naive JavaScript Implementation (Working v1)
 * ============================================================================
 * 
 * BLAKE3 - это криптографическая хэш-функция, разработанная в 2020 году.
 * Она объединяет лучшие качества BLAKE2 и Bao (параллельное дерево Меркла).
 * 
 * Основные характеристики:
 * - Размер блока: 64 байта
 * - Размер чанка: 1024 байта (16 блоков)
 * - Размер вывода: 32 байта (по умолчанию), но поддерживает XOF
 * - Количество раундов: 7 (вместо 10 в BLAKE2s)
 * 
 * Структура алгоритма:
 * 1. Входные данные разбиваются на чанки по 1024 байта
 * 2. Каждый чанк обрабатывается как цепочка из 16 блоков по 64 байта
 * 3. Результаты чанков объединяются в дерево Меркла
 * 4. Корень дерева даёт финальный хэш
 * 
 * Вход:  Uint8Array (любой длины)
 * Выход: Uint8Array (32 байта)
 */

/**
 * ============================================================================
 * BLAKE3 v1 — Оптимизация чтения блоков
 * ============================================================================
 * 
 * Оптимизации в этой версии:
 * - v1: Убрана проверка границ массива из "горячего" цикла
 *       
 *       Было (v0): одна функция readLittleEndianWords с проверками на каждой итерации
 *       Стало (v1): две специализированные функции:
 *         - readLittleEndianWordsFull: для полных 64-байтных блоков (без проверок)
 *         - readLittleEndianWordsPartial: для последнего блока (с проверками)
 *       
 *       Результат: ускорение ~85x (с 22.4 с до 262 мс на 1 МБ)
 */

// ============================================================================
// КОНСТАНТЫ
// ============================================================================

/**
 * Вектор инициализации (IV) - первые 32 бита дробной части 
 * квадратных корней первых 8 простых чисел: √2, √3, √5, √7, √11, √13, √17, √19
 * 
 * Эти же константы используются в SHA-256 и BLAKE2s.
 * Они выбраны как "nothing-up-my-sleeve numbers" - числа, которые
 * невозможно подобрать специально для создания backdoor.
 */
const IV = new Uint32Array([
  0x6a09e667,  // √2
  0xbb67ae85,  // √3
  0x3c6ef372,  // √5
  0xa54ff53a,  // √7
  0x510e527f,  // √11
  0x9b05688c,  // √13
  0x1f83d9ab,  // √17
  0x5be0cd19,  // √19
]);

/**
 * Флаги домена - указывают тип обрабатываемого блока.
 * Используются для domain separation (разделения доменов),
 * чтобы одинаковые данные в разных контекстах давали разные хэши.
 */
const CHUNK_START = 1;   // 0b0001 - первый блок в чанке
const CHUNK_END = 2;     // 0b0010 - последний блок в чанке
const PARENT = 4;        // 0b0100 - родительский узел в дереве Меркла
const ROOT = 8;          // 0b1000 - корневой узел (финальный хэш)
// Также существуют: KEYED_HASH = 16, DERIVE_KEY_CONTEXT = 32, DERIVE_KEY_MATERIAL = 64

/**
 * Размер блока в байтах.
 * BLAKE3 обрабатывает данные блоками по 64 байта = 16 слов по 4 байта.
 */
const BLOCK_LEN = 64;

/**
 * Таблица перестановки сообщения между раундами.
 * После каждого раунда слова сообщения переставляются по этой таблице.
 * 
 * Пример: слово с индексом 0 переходит на позицию 2,
 *         слово с индексом 1 переходит на позицию 6, и т.д.
 * 
 * Это обеспечивает лучшее перемешивание (diffusion) данных.
 */
const MSG_PERMUTATION = [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];


// ============================================================================
// БАЗОВЫЕ ОПЕРАЦИИ
// ============================================================================

/**
 * Циклический сдвиг вправо (rotate right).
 * 
 * В отличие от обычного сдвига (>>), биты не теряются,
 * а переходят с правого края на левый.
 * 
 * Пример для 8 бит: rightRotate(0b11110000, 2) = 0b00111100
 * 
 * @param {number} word - 32-битное слово
 * @param {number} bits - количество позиций для сдвига
 * @returns {number} - результат циклического сдвига
 * 
 * Примечание: НЕ используем >>> 0 в конце, так как побитовые операции
 * в JavaScript автоматически приводят результат к 32-битному целому.
 */
function rightRotate(word, bits) {
  return (word >>> bits) | (word << (32 - bits));
}

/**
 * G-функция - сердце BLAKE3.
 * 
 * Это четвертьраундовая функция (quarter-round), которая смешивает
 * 4 слова состояния (a, b, c, d) с двумя словами сообщения (mx, my).
 * 
 * Схема работы (ARX - Add-Rotate-XOR):
 * 
 *   a ← a + b + mx
 *   d ← (d ⊕ a) >>> 16
 *   c ← c + d
 *   b ← (b ⊕ c) >>> 12
 *   a ← a + b + my
 *   d ← (d ⊕ a) >>> 8
 *   c ← c + d
 *   b ← (b ⊕ c) >>> 7
 * 
 * Константы ротации (16, 12, 8, 7) оптимизированы для 32-битных слов.
 * 
 * @param {Uint32Array} state - массив из 16 слов состояния
 * @param {number} a, b, c, d - индексы смешиваемых слов
 * @param {number} mx, my - слова сообщения для подмешивания
 * 
 * Примечание: используем | 0 после сложения для принудительного
 * приведения к 32-битному знаковому целому (как в эталонной реализации).
 */
function g(state, a, b, c, d, mx, my) {
  // Первая половина: подмешиваем mx
  state[a] = (((state[a] + state[b]) | 0) + mx) | 0;  // a ← a + b + mx
  state[d] = rightRotate(state[d] ^ state[a], 16);    // d ← (d ⊕ a) >>> 16
  state[c] = (state[c] + state[d]) | 0;               // c ← c + d
  state[b] = rightRotate(state[b] ^ state[c], 12);    // b ← (b ⊕ c) >>> 12
  
  // Вторая половина: подмешиваем my
  state[a] = (((state[a] + state[b]) | 0) + my) | 0;  // a ← a + b + my
  state[d] = rightRotate(state[d] ^ state[a], 8);     // d ← (d ⊕ a) >>> 8
  state[c] = (state[c] + state[d]) | 0;               // c ← c + d
  state[b] = rightRotate(state[b] ^ state[c], 7);     // b ← (b ⊕ c) >>> 7
}

/**
 * Раунд - применяет G-функцию ко всем 16 словам состояния.
 * 
 * Состояние представляется как матрица 4×4:
 * 
 *   ┌──────┬──────┬──────┬──────┐
 *   │  0   │  1   │  2   │  3   │
 *   ├──────┼──────┼──────┼──────┤
 *   │  4   │  5   │  6   │  7   │
 *   ├──────┼──────┼──────┼──────┤
 *   │  8   │  9   │ 10   │ 11   │
 *   ├──────┼──────┼──────┼──────┤
 *   │ 12   │ 13   │ 14   │ 15   │
 *   └──────┴──────┴──────┴──────┘
 * 
 * Раунд состоит из двух фаз:
 * 
 * 1. КОЛОНКИ - G применяется к каждому столбцу:
 *    G(0,4,8,12)  G(1,5,9,13)  G(2,6,10,14)  G(3,7,11,15)
 * 
 * 2. ДИАГОНАЛИ - G применяется к диагоналям:
 *    G(0,5,10,15) G(1,6,11,12) G(2,7,8,13)   G(3,4,9,14)
 * 
 * @param {Uint32Array} state - состояние из 16 слов
 * @param {Uint32Array} m - блок сообщения из 16 слов
 */
function round(state, m) {
  // Фаза 1: обработка колонок
  g(state, 0, 4,  8, 12, m[0],  m[1]);   // колонка 0
  g(state, 1, 5,  9, 13, m[2],  m[3]);   // колонка 1
  g(state, 2, 6, 10, 14, m[4],  m[5]);   // колонка 2
  g(state, 3, 7, 11, 15, m[6],  m[7]);   // колонка 3
  
  // Фаза 2: обработка диагоналей
  g(state, 0, 5, 10, 15, m[8],  m[9]);   // диагональ 0
  g(state, 1, 6, 11, 12, m[10], m[11]);  // диагональ 1
  g(state, 2, 7,  8, 13, m[12], m[13]);  // диагональ 2
  g(state, 3, 4,  9, 14, m[14], m[15]);  // диагональ 3
}

/**
 * Перестановка слов сообщения между раундами.
 * 
 * После каждого раунда слова сообщения переставляются
 * согласно таблице MSG_PERMUTATION. Это обеспечивает,
 * что в каждом раунде G-функции получают слова в разном порядке.
 * 
 * @param {Uint32Array} m - блок сообщения (модифицируется на месте)
 */
function permute(m) {
  const copy = new Uint32Array(m);  // Сохраняем копию
  for (let i = 0; i < 16; ++i) {
    m[i] = copy[MSG_PERMUTATION[i]];
  }
}


// ============================================================================
// ФУНКЦИЯ СЖАТИЯ
// ============================================================================

/**
 * Функция сжатия - основная криптографическая операция BLAKE3.
 * 
 * Принимает:
 * - chainingValue: 8 слов (256 бит) - результат предыдущего сжатия или IV
 * - blockWords: 16 слов (512 бит) - блок данных
 * - counter: 64-битный счётчик чанков
 * - blockLen: длина блока в байтах (для паддинга)
 * - flags: флаги домена
 * 
 * Возвращает: 16 слов (512 бит) - результат сжатия
 * 
 * Начальное состояние (16 слов = 512 бит):
 * 
 *   ┌─────────────────────────────────────────────────┐
 *   │  h0    h1    h2    h3   ← chaining value (0-3)  │
 *   │  h4    h5    h6    h7   ← chaining value (4-7)  │
 *   │ IV0   IV1   IV2   IV3   ← константы IV          │
 *   │  t0    t1  blen  flags  ← counter, len, flags   │
 *   └─────────────────────────────────────────────────┘
 * 
 * @param {Uint32Array} chainingValue - входное сцепляющее значение (8 слов)
 * @param {Uint32Array} blockWords - блок сообщения (16 слов)
 * @param {number} counter - номер чанка (младшие 32 бита)
 * @param {number} blockLen - длина данных в блоке
 * @param {number} flags - флаги домена
 * @returns {Uint32Array} - результат сжатия (16 слов)
 */
function compress(chainingValue, blockWords, counter, blockLen, flags) {
  // Инициализация состояния
  const state = new Uint32Array([
    // Строки 0-1: сцепляющее значение (результат предыдущего блока или IV)
    chainingValue[0], chainingValue[1], chainingValue[2], chainingValue[3],
    chainingValue[4], chainingValue[5], chainingValue[6], chainingValue[7],
    // Строка 2: константы IV
    IV[0], IV[1], IV[2], IV[3],
    // Строка 3: счётчик (64 бита), длина блока, флаги
    counter,                      // t0: младшие 32 бита счётчика
    (counter / 0x100000000) | 0,  // t1: старшие 32 бита (counter >> 32)
    blockLen,                     // длина данных в блоке
    flags,                        // флаги домена
  ]);

  // Копия блока сообщения (будет модифицироваться permute)
  const block = new Uint32Array(blockWords);

  // 7 раундов с перестановкой после каждого
  // (в BLAKE2 - 10 раундов, BLAKE3 оптимизирован для скорости)
  round(state, block); permute(block);  // Раунд 1
  round(state, block); permute(block);  // Раунд 2
  round(state, block); permute(block);  // Раунд 3
  round(state, block); permute(block);  // Раунд 4
  round(state, block); permute(block);  // Раунд 5
  round(state, block); permute(block);  // Раунд 6
  round(state, block); permute(block);  // Раунд 7

  // Финализация: XOR верхней и нижней половин состояния
  // Это "сжимает" 512 бит до 256 бит и добавляет feed-forward
  for (let i = 0; i < 8; ++i) {
    state[i] ^= state[i + 8];           // out[i] = state[i] ⊕ state[i+8]
    state[i + 8] ^= chainingValue[i];   // out[i+8] = state[i+8] ⊕ h[i]
  }

  return state;
}

/**
 * Извлекает первые 8 слов (256 бит) из результата сжатия.
 * 
 * Это "сцепляющее значение" (chaining value), которое передаётся
 * в следующий блок или используется как узел дерева Меркла.
 * 
 * @param {Uint32Array} compressionOutput - результат compress (16 слов)
 * @returns {Uint32Array} - первые 8 слов (новый массив)
 */
function first8Words(compressionOutput) {
  return new Uint32Array(compressionOutput).slice(0, 8);
}

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * Читает байты как little-endian 32-битные слова.
 * 
 * Little-endian означает, что младший байт идёт первым.
 * Пример: байты [0x78, 0x56, 0x34, 0x12] → слово 0x12345678
 * 
 * Функция также обрабатывает неполные блоки (паддинг нулями).
 * 
 * @param {Uint8Array} array - входные байты
 * @param {number} offset - начальная позиция
 * @param {Uint32Array} words - массив для записи слов (16 элементов)
 */
// ═══════════════════════════════════════════════════════════════════════════
// ✅ ОПТИМИЗАЦИЯ: Две версии функции чтения
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Быстрое чтение полного блока (64 байта).
 * Без проверок границ - для 99% вызовов.
 */
function readLittleEndianWordsFull(array, offset, words) {
  for (let i = 0; i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
}

/**
 * Чтение неполного блока с padding.
 * Только для последнего блока данных.
 */
function readLittleEndianWordsPartial(array, offset, words) {
  let i = 0;
  for (; offset + 3 < array.length && i < 16; ++i, offset += 4) {
    words[i] =
      array[offset] |
      (array[offset + 1] << 8) |
      (array[offset + 2] << 16) |
      (array[offset + 3] << 24);
  }
  for (let j = i; j < 16; ++j) words[j] = 0;
  for (let s = 0; offset < array.length; s += 8, ++offset) {
    words[i] |= array[offset] << s;
  }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

/**
 * Вычисляет BLAKE3 хэш входных данных.
 * 
 * Алгоритм работает в три этапа:
 * 
 * 1. ОБРАБОТКА ПОЛНЫХ ЧАНКОВ (по 1024 байта):
 *    - Каждый чанк состоит из 16 блоков по 64 байта
 *    - Блоки цепочкой сжимаются в одно 256-битное значение
 *    - Результаты чанков складываются в стек для дерева Меркла
 * 
 * 2. ОБРАБОТКА ПОСЛЕДНЕГО (НЕПОЛНОГО) ЧАНКА:
 *    - Может содержать от 0 до 1023 байт
 *    - Паддится нулями до границы блока
 * 
 * 3. ПОСТРОЕНИЕ ДЕРЕВА МЕРКЛА:
 *    - Пары узлов объединяются в родительские узлы
 *    - Повторяется до получения единственного корня
 *    - Корень хэшируется с флагом ROOT
 * 
 * Визуализация дерева для 4 чанков:
 * 
 *              ROOT
 *             /    \
 *        PARENT    PARENT
 *        /   \     /    \
 *     CV0   CV1  CV2   CV3
 *      |     |    |     |
 *   Chunk0 Chunk1 Chunk2 Chunk3
 * 
 * @param {Uint8Array} input - входные данные
 * @returns {Uint8Array} - хэш (32 байта)
 */
function blake3(input) {
  // Проверка типа входных данных
  if (!(input instanceof Uint8Array)) {
    throw new Error('Input must be Uint8Array');
  }

  // Инициализация
  const flags = 0;                    // Базовые флаги (можно добавить KEYED_HASH и др.)
  const keyWords = IV;                // Ключ (IV для обычного хэширования)
  const blockWords = new Uint32Array(16);  // Буфер для блока
  const cvStack = [];                 // Стек для дерева Меркла

  let chunkCounter = 0;               // Счётчик обработанных чанков
  let offset = 0;                     // Текущая позиция во входных данных

  const length = input.length;
  
  // Вычисляем, сколько полных чанков обработать
  // take = наибольшее число, кратное 1024, которое < length
  const take = Math.max(0, ((length - 1) | 1023) - 1023);

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 1: Обработка полных чанков (по 1024 байта = 16 блоков)
  // ═══════════════════════════════════════════════════════════════════════
  
  for (; offset < take; ) {
    let cv = keyWords;  // Сцепляющее значение (начинаем с IV)

    // Обрабатываем 16 блоков чанка
    for (let i = 0; i < 16; ++i, offset += 64) {
      readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

      // Определяем флаги для блока:
      // - Первый блок: CHUNK_START
      // - Последний блок (15-й): CHUNK_END
      // - Остальные: без флагов
      cv = first8Words(
        compress(
          cv,
          blockWords,
          chunkCounter,
          BLOCK_LEN,
          flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
        )
      );
    }

    chunkCounter += 1;
    cvStack.push(cv);  // Добавляем результат чанка в стек

    // Объединяем узлы дерева Меркла, пока можем
    // (пока количество чанков кратно 2)
    let totalChunks = chunkCounter;
    while ((totalChunks & 1) === 0) {
      // Извлекаем два дочерних узла
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      
      // Формируем блок для родительского узла:
      // левый потомок (8 слов) + правый потомок (8 слов) = 16 слов
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      
      // Сжимаем с флагом PARENT
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
      
      totalChunks >>= 1;
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 2: Обработка последнего (возможно неполного) чанка
  // ═══════════════════════════════════════════════════════════════════════

  const remainingBytes = length - take;
  const fullBlocks = remainingBytes > 0 ? ((remainingBytes - 1) / 64) | 0 : 0;

  let cv = keyWords;

  // Обрабатываем полные блоки последнего чанка
  for (let i = 0; i < fullBlocks; ++i, offset += 64) {
    readLittleEndianWordsFull(input, offset, blockWords);  // ✅ Быстрая версия

    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        BLOCK_LEN,
        flags | (i === 0 ? CHUNK_START : i === 15 ? CHUNK_END : 0)
      )
    );
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ЭТАП 3: Финализация - обработка последнего блока и построение корня
  // ═══════════════════════════════════════════════════════════════════════

  let finalChainingValue;
  let finalBlockLen;
  let finalFlags;

  // Читаем последний блок (может быть неполным)
  readLittleEndianWordsPartial(input, offset, blockWords);  // ✅ С проверками границ

  if (cvStack.length === 0) {
    // Особый случай: все данные помещаются в один чанк
    // Финальный блок - это и корень дерева
    finalChainingValue = cv;
    finalBlockLen = length - offset;
    finalFlags = flags | ROOT | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0);
  } else {
    // Общий случай: нужно построить дерево Меркла
    finalChainingValue = keyWords;
    finalBlockLen = BLOCK_LEN;
    finalFlags = flags | PARENT | ROOT;

    // Завершаем последний чанк
    cv = first8Words(
      compress(
        cv,
        blockWords,
        chunkCounter,
        length - offset,
        flags | CHUNK_END | (fullBlocks === 0 ? CHUNK_START : 0)
      )
    );

    cvStack.push(cv);

    // Объединяем оставшиеся узлы в дерево
    while (cvStack.length > 2) {
      const rightChildCv = cvStack.pop();
      const leftChildCv = cvStack.pop();
      blockWords.set(leftChildCv, 0);
      blockWords.set(rightChildCv, 8);
      cv = first8Words(
        compress(keyWords, blockWords, 0, BLOCK_LEN, flags | PARENT)
      );
      cvStack.push(cv);
    }

    // Подготавливаем финальный блок из двух последних узлов
    const rightChildCv = cvStack.pop();
    const leftChildCv = cvStack.pop();
    blockWords.set(leftChildCv, 0);
    blockWords.set(rightChildCv, 8);
  }

  // Финальное сжатие с флагом ROOT
  const out = compress(
    finalChainingValue,
    blockWords,
    0,
    finalBlockLen,
    finalFlags
  );

  // Возвращаем первые 32 байта (256 бит) как хэш
  return new Uint8Array(out.buffer, 0, 32);
}
const hash = blake3;


// ============================================================================
// ЭКСПОРТ
// ============================================================================

export { blake3 };

/*
┌─────────────────────────────────────────────────────────────────┐
│                         ВХОДНЫЕ ДАННЫЕ                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Разбиение на ЧАНКИ (1024 байта = 16 блоков по 64 байта)        │
└─────────────────────────────────────────────────────────────────┘
                              │
            ┌─────────────────┼─────────────────┐
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │ Chunk 0 │       │ Chunk 1 │       │ Chunk N │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            ▼                 ▼                 ▼
       ┌─────────┐       ┌─────────┐       ┌─────────┐
       │   CV0   │       │   CV1   │       │   CVN   │
       └────┬────┘       └────┬────┘       └────┬────┘
            │                 │                 │
            └────────┬────────┴────────┬────────┘
                     ▼                 ▼
                ┌─────────┐       ┌─────────┐
                │ PARENT  │       │ PARENT  │
                └────┬────┘       └────┬────┘
                     └────────┬────────┘
                              ▼
                         ┌─────────┐
                         │  ROOT   │
                         └────┬────┘
                              │
                              ▼
                   ┌───────────────────┐
                   │   HASH (32 bytes) │
                   └───────────────────┘
*/
